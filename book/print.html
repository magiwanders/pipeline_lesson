<!DOCTYPE HTML>
<html lang="it" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Pipelining</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="scrollbar.css">
        <link rel="stylesheet" href="loader.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_overview.html"><strong aria-hidden="true">1.</strong> Overview and Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1_hex_2scomplement_rv32i.html"><strong aria-hidden="true">1.1.</strong> Review of RISC-V Instruction Set, 2's complement and Hex Calculations</a></li><li class="chapter-item expanded "><a href="1.2_components_review.html"><strong aria-hidden="true">1.2.</strong> Review of Single Cycle Processor Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.2.1_single_register.html"><strong aria-hidden="true">1.2.1.</strong> Single Register</a></li><li class="chapter-item expanded "><a href="1.2.2_rom.html"><strong aria-hidden="true">1.2.2.</strong> ROM</a></li><li class="chapter-item expanded "><a href="1.2.3_register_file.html"><strong aria-hidden="true">1.2.3.</strong> Register File</a></li><li class="chapter-item expanded "><a href="1.2.4_pc.html"><strong aria-hidden="true">1.2.4.</strong> PC</a></li><li class="chapter-item expanded "><a href="1.2.5_alu.html"><strong aria-hidden="true">1.2.5.</strong> ALU</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="2_timing.html"><strong aria-hidden="true">2.</strong> Circuit Timing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1_propagation_delay.html"><strong aria-hidden="true">2.1.</strong> Gates and Chips Operate with a Propagation Delay</a></li><li class="chapter-item expanded "><a href="2.2_rtl.html"><strong aria-hidden="true">2.2.</strong> Propagation Delay Poses an Upper Limit to the Speed of RTL Circuits</a></li><li class="chapter-item expanded "><a href="2.3_diagramma_rtl.html"><strong aria-hidden="true">2.3.</strong> Keeping Track of the Dynamic Behaviour of RTL Circuits with Diagrams</a></li><li class="chapter-item expanded "><a href="2.4_pipeline.html"><strong aria-hidden="true">2.4.</strong> Introduction to the Pipelined Processor</a></li></ol></li><li class="chapter-item expanded "><a href="3_building_the_pipeline.html"><strong aria-hidden="true">3.</strong> Building the Pipelined Processor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1_from_singlecycle.html"><strong aria-hidden="true">3.1.</strong> Grouping the Components of the Single-Cycle Processor into Stages</a></li><li class="chapter-item expanded "><a href="3.2_stages.html"><strong aria-hidden="true">3.2.</strong> An Overview of how Each Inctruction Activates Each Stage</a></li></ol></li><li class="chapter-item expanded "><a href="4_demos.html"><strong aria-hidden="true">4.</strong> Executing Programs on the Pipelined Register</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1_simple_meaningless_program.html"><strong aria-hidden="true">4.1.</strong> DEMO - Meaningless Program</a></li><li class="chapter-item expanded "><a href="4.2_towards_hazards.html"><strong aria-hidden="true">4.2.</strong> DEMO - Program Towards Hazards</a></li><li class="chapter-item expanded "><a href="4.3_assignments.html"><strong aria-hidden="true">4.3.</strong> Assignment on Hazards</a></li></ol></li><li class="chapter-item expanded "><a href="5_appendix.html"><strong aria-hidden="true">5.</strong> RV32IMAC Cheat Sheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Pipelining</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview-and-prerequisites"><a class="header" href="#overview-and-prerequisites">Overview and Prerequisites</a></h1>
<p>This lesson can be navigated with the menu on the left (first icon on the top left) or even only with the <code>Arrow Right</code> e <code>Arrow Left</code> keys.</p>
<p>This site uses no server side cookies. Local storage is used, but only not to lose the user input to the site's widgets at every page refresh.</p>
<p>After watching the overview video below, click <code>Arrow Right</code>, or choose from the menu on the left.</p>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/kLswTs3N_Kc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="transcript"><a class="header" href="#transcript">Transcript</a></h2>
<p>In this lesson we are going modify the hardware of a single cycle processor, building a new computer architecture paradigm that allows more instructions to be processed in the same amount of time, without loss of functionality.</p>
<p>In order to understand the lesson, you should have just studied a single cycle processor design, and have a strong grasp of the functioning of each of its components. We are going to start from such a design to handcraft the new hardware organization. Similarly you should have a base knowledge of the RISC 5 RV 32 I Instruction Set, since its characteristics and nuances are reflected in the architecture, and we are going to use assembly examples and case studies.</p>
<p>This also implies that you are comfortable with hex and 2's complement calculations and conversions, as well as with register aliases (RISC 5 ABI names).</p>
<p>The lesson contains the tools you need to review all this material and keep it at hand. In particular, at the end of the lesson there is a link to some RISC 5 cheat sheets, that contains all the info you might need on the instruction set and on the ABI register names. The following section contains some exercises on encoding and decoding, together with hex and 2's complement calculations and conversions. Finally, the last part of the prerequisites sections, contains some interactive models, of some of the most important components of the processor. Later in the lesson we will use a visual processor simulator, and you will be asked to do exercises on it. If you have any doubts and need a level of granularity greater than what it offers, use these interactive models to review your knowledge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-of-risc-v-instruction-set-2s-complement-and-hex-calculations"><a class="header" href="#review-of-risc-v-instruction-set-2s-complement-and-hex-calculations">Review of RISC-V Instruction Set, 2's complement and Hex Calculations</a></h1>
<p>Remember than there is a link to a <a href="./5_appendix.html">RV32IMAC Cheat Sheet</a> at the end of the lesson.</p>
<ol>
<li>
<p>Disassemble the following instructions:</p>
<ol>
<li><code>0x01e007ef</code></li>
<li><code>0x0001e7b7</code></li>
<li><code>0x00440113</code></li>
<li><code>0x40445113</code></li>
<li><code>0x403100b3</code></li>
<li><code>0xfea64ae3</code></li>
<li><code>0x0003a583</code></li>
<li><code>0x00b3a023</code></li>
</ol>
</li>
<li>
<p>Assemble the following instructions:</p>
<ol>
<li><code>j -12</code></li>
<li><code>auipc sp 8</code></li>
<li><code>andi sp, s0, 4</code></li>
<li><code>sltiu sp, s0, 4</code></li>
<li><code>or ra, sp, gp</code></li>
<li>Solo l'istruzione di branch del seguente programma:
<ul>
<li><code>&lt;LABEL&gt;</code></li>
<li>    <code>lw a1 0(t2)</code></li>
<li>    <code>add a2 a1 a1</code></li>
<li>    <code>sw a1 0(t2)</code></li>
<li>    <code>bgtz sp &lt;LABEL&gt;</code></li>
</ul>
</li>
<li><code>lw a7 8(t2)</code></li>
<li><code>sw a7 8(t2)</code></li>
</ol>
</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="disassembling-instruction-0x01e007ef"><a class="header" href="#disassembling-instruction-0x01e007ef">Disassembling instruction <code>0x01e007ef</code></a></h3>
<p>First, convert hex into binary:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">hex</th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>1</code></th><th style="text-align: center"><code>e</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>7</code></th><th style="text-align: center"><code>e</code></th><th style="text-align: center"><code>f</code></th></tr></thead><tbody>
<tr><td style="text-align: center">bin</td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0001</code></td><td style="text-align: center"><code>1110</code></td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0111</code></td><td style="text-align: center"><code>1110</code></td><td style="text-align: center"><code>1111</code></td></tr>
</tbody></table>
</div>
<p>Then identify the instruction at hand using the tables from the <a href="./5_appendix.html">RV32IMAC Cheat Sheet</a>. Instructions are better decoded reading them from right to left, so that the first thing you find are its quadrant and opcode.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">RV32I</th><th style="text-align: center"><code>00000001111000000000</code></th><th style="text-align: center"><code>01111</code></th><th style="text-align: center"><code>11011</code></th><th style="text-align: center"><code>11</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Meaning</td><td style="text-align: center"><code>&lt;imm&gt; (encoded)</code></td><td style="text-align: center"><code>rd</code></td><td style="text-align: center"><code>opcode</code></td><td style="text-align: center"><code>quadrant</code></td></tr>
<tr><td style="text-align: center">Value</td><td style="text-align: center"><code>&lt;imm&gt;</code></td><td style="text-align: center">15</td><td style="text-align: center">Jump and Link</td><td style="text-align: center">4th</td></tr>
</tbody></table>
</div>
<p>We therefore obtain <code>jal x15 &lt;imm&gt;</code>, where <code>&lt;imm&gt;</code> is the still to be decoded immediate.</p>
<p>All the instruction fields except <code>&lt;imm&gt;</code> are decodable just from the tables, for this instruction. For <code>&lt;imm&gt;</code> we have to further scramble some bits to decode it.</p>
<p>Identify the subfields of the immediate:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>&lt;imm&gt; (encoded)</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>0000001111</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>00000000</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Encoding</td><td style="text-align: center"><code>m2</code></td><td style="text-align: center"><code>imm2</code></td><td style="text-align: center"><code>m1</code></td><td style="text-align: center"><code>imm1</code></td></tr>
</tbody></table>
</div>
<p>Re-order the subfields as written on the tables. Usually the immediate encoding is just below the corresponding instruction's encoding.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Decoding di <code>&lt;imm&gt;</code></th><th style="text-align: center"><code>-m2-</code></th><th style="text-align: center"><code>imm1</code></th><th style="text-align: center"><code>m1</code></th><th style="text-align: center"><code>imm2</code></th><th style="text-align: center"><code>0</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&lt;imm&gt; (bin)</code></td><td style="text-align: center"><code>000000000000</code></td><td style="text-align: center"><code>00000000</code></td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>0000001111</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
</div>
<p>We obtain the 2's complement </p>
<ul>
<li><code>&lt;imm&gt; (bin)</code> = <code>00000000000000000000000000011110</code> </li>
</ul>
<p>that is the decimal</p>
<ul>
<li><code>&lt;imm&gt; (dec)</code> = <code>30</code></li>
</ul>
<p>The complete disassembled instruction is therefore <code>jal x15 30</code>, o <code>jal a5 30</code> using the ABI register aliases.</p>
<h3 id="assembling-instruction-j--12"><a class="header" href="#assembling-instruction-j--12">Assembling instruction <code>j -12</code></a></h3>
<p>Find the instruction <code>j</code> on the encoding part of the <a href="./5_appendix.html">RV32IMAC Cheat Sheet</a>. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Instruction Encoding <code>j</code></th><th style="text-align: center"><code>&lt;imm&gt; (encoded)</code></th><th style="text-align: center">00000</th><th style="text-align: center">11011</th><th style="text-align: center">11</th></tr></thead><tbody>
</tbody></table>
</div>
<p>We therefore know the least significant bits <code>xxxxxxxxxxxxxxxxxxxx000001101111</code>. The rest is just an immediate, <code>&lt;imm&gt; = 30 </code>, which we now have to encode.</p>
<p>First convert <code>&lt;imm&gt;</code> = <code>-12</code> to 2's complement <code>&lt;imm&gt; (bin)</code> = <code>10100</code>, and now sign-extend it to cover all the 32 bits of its width <code>&lt;imm&gt; (bin)</code> = <code>11111111111111111111111111110100</code>.</p>
<p>Divide this number into its subfields as of <a href="./5_appendix.html">RV32IMAC Cheat Sheet</a>, Encoder section. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>&lt;imm&gt; (bin)</code></th><th style="text-align: center"><code>111111111111</code></th><th style="text-align: center"><code>11111111</code></th><th style="text-align: center"><code>1</code></th><th style="text-align: center"><code>1111111010</code></th><th style="text-align: center"><code>0</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Decoding <code>&lt;imm&gt;</code></td><td style="text-align: center"><code>-m2-</code></td><td style="text-align: center"><code>imm1</code></td><td style="text-align: center"><code>m1</code></td><td style="text-align: center"><code>imm2</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
</div>
<p>Re-order the fields to encode the immediate:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Encoding</th><th style="text-align: center"><code>m2</code></th><th style="text-align: center"><code>imm2</code></th><th style="text-align: center"><code>m1</code></th><th style="text-align: center"><code>imm1</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&lt;imm&gt; (encoded)</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center"><code>1111111010</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center"><code>11111111</code></td></tr>
</tbody></table>
</div>
<p>We obtain <code>&lt;imm&gt; (encoded)</code> = <code>11111111010111111111xxxxxxxxxxxx</code>, that are the missing most significant bits. </p>
<p>The complete assembled instruction is therefore <code>11111111010111111111000001101111</code>, after having jointed the two half-results above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-of-single-cycle-processor-components"><a class="header" href="#review-of-single-cycle-processor-components">Review of Single Cycle Processor Components</a></h1>
<p>The following pages contain interactive examples of these circuits:</p>
<ul>
<li><a href="./1.2.1_single_register.html">32 bit Register</a></li>
<li><a href="./1.2.2_rom.html">8 bit ROM</a></li>
<li><a href="./1.2.3_register_file.html">32 bit Register File (RF)</a></li>
<li><a href="./1.2.4_pc.html">8 bit PC</a></li>
<li><a href="./1.2.5_alu.html">32 bit ALU</a></li>
</ul>
<p>The circuits are implemented in S.H.E.A.S.</p>
<h2 id="sheas-tool-tutorial"><a class="header" href="#sheas-tool-tutorial">S.H.E.A.S. Tool Tutorial</a></h2>
<p>S.H.E.A.S. is a logic ports simulator also available <a href="https://sheas.magiwanders.com">standalone</a>. It will however be mostly embedded in the lesson pages.</p>
<iframe width="854" height="480" src="https://www.youtube.com/embed/CUn9LVzQL0g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="trasncript-v11"><a class="header" href="#trasncript-v11">TRASNCRIPT (v1.1)</a></h2>
<p>This is a basic tutorial for SHEAS one point one, a tool based on the DigitalJS open source logic simulation engine, originally created for visualizing and simulating verilog code by Marek Materzock. </p>
<p>SHEAS stands for Simple Hardware Editor And Simulator, and it provides DigitalJS with a basic interface that allows for completely code-free hardware modification and simulation, and in a near future, testing too. </p>
<p>SHEAS is open source too, and a live running page can be found at sheas.magiwanders.com.</p>
<p>Components are chosen from the dropdown and added to the simulation. The base components are buttons for inputs, lamps for outputs, and nand ports for synthesizing logic. Each of these has a 'bits' attribute which describes the width of their ports. More components are available in the dropdown and new ones are constantly added. </p>
<p>In the Visualization Window, components are moved by drag and drop and connected by dragging and dropping, from the output of one to the input of the other. If any glitch happens, the visualization can at any point be reloaded.</p>
<p>The simulation is already running by default, and at any point, clicking the blue looking glass that appears upon hovering each wire will activate a signal monitor below. To see the details, like the exact delay between signal activations, the simulation can be paused and forwarded step by step, while the signal monitors can be zoomed in and out, and navigated horizontally to the left or to the right. </p>
<p>Any component can be renamed. Any component can also be removed by name.
No two components can have the same name, the page will output an error if trying to rename one to an already existing name.</p>
<p>At any point, the circuit can be saved for later retrieval, and the simulation can be reset.</p>
<p>Saved circuits are retrieved either as they were saved, with the load button, or as black boxes, with the add button. The black box can be used as any other component, and its internal ports can be accessed with the looking glass icon that appears upon hovering it.</p>
<p>At any point the current circuit can be shared by clicking the 'share circuit as link' button and pasting the link into another window. Mind that due to the limitations on the URL length, this only works for all but the biggest circuits. Alternatively, clicking the 'share only the chip' button will copy the chip in the clipboard. In another window, the chip can be retrieved with the dropdown option 'Circuit from Clipboard'.  This works with much bigger circuits.</p>
<p>That is all, thank you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-register-32-bits"><a class="header" href="#single-register-32-bits">Single Register (32 bits)</a></h1>
<p>When detecting the rising edge of a clock signal, the register updates its output with the value of its input.</p>
<div id="sheas_container_register"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rom"><a class="header" href="#rom">ROM</a></h1>
<p>A memory is nothing but a bank of registers: given an address input, the memory retrieves the content of the register with that index as output.
Remember that a non-writable memory is a good model for the processor's instruction memory.</p>
<p>The memory in this circuit contains the program:</p>
<ul>
<li><code>&lt;LABEL&gt;</code></li>
<li>    <code>lw a1 0(t2)</code></li>
<li>    <code>add a2 a1 a1</code></li>
<li>    <code>sw a1 0(t2)</code></li>
<li>    <code>bgtz sp &lt;LABEL&gt;</code></li>
</ul>
<div id="sheas_container_rom"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-file-rf"><a class="header" href="#register-file-rf">Register File (RF)</a></h1>
<p>Design of the 32 bit RF by <a href="https://github.com/tilk">Marek Materzok</a>. This design is purely functional, it does not get to the level of detail of logic ports.
The register file contains the 32 registers that are referred to in the assembly code as x0-x31, or with the corresponding ABI names. What distinguishes the register file from a normal memory is that it can read to registers at once, while simultaneously writing another one.</p>
<div id="sheas_container_registerfile"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pc"><a class="header" href="#pc">PC</a></h1>
<p>The program counter is a register that contains the value of the next instruction to execute, which is decided by either incrementing it by 4 (which means selecting the next instruction) or receiving the alu result from the branch or jump calculation of the branch/jump address.</p>
<div id="sheas_container_pc"><div style="width:100%; height:100%"><div class="loader"></div></div></div><div style="break-before: page; page-break-before: always;"></div><h1 id="alu"><a class="header" href="#alu">ALU</a></h1>
<p>32 bits ALU design by <a href="https://github.com/tilk">Marek Materzok</a>). This design is purely functional, it does not get to the level of detail of logic ports.</p>
<p>The alu receives as input two values and a function to execute on them. The result is given as output, together with a flag that indicates if the result is zero.</p>
<div id="sheas_container_alu"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-timing"><a class="header" href="#circuit-timing">Circuit Timing</a></h1>
<p>In the next section we are going to study the propagation delay of circuits and how this impacts and limits the design of processors.</p>
<h3 id="index"><a class="header" href="#index">Index</a></h3>
<ul>
<li><a href="./2.1_propagation_delay.html">Gates and Chips Operate with a Propagation Delay</a></li>
<li><a href="./2.2_rtl.html">Propagation Delay Poses an Upper Limit to the Speed of RTL Circuits</a></li>
<li><a href="./2.3_diagramma_rtl.html">Keeping Track of the Dynamic Behaviour of RTL Circuits with Diagrams</a></li>
<li><a href="./2.4_pipeline.html">Introduction to the Pipelined Processor</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consequences-of-a-non-negligible-propagation-delay"><a class="header" href="#consequences-of-a-non-negligible-propagation-delay">Consequences of a Non-Negligible Propagation Delay</a></h1>
<p>This part of the lesson deals with the delay with which logic gates calculate their output, which is not zero. This propagation delay, which we often ignore, has consequences on the maximum clock frequency of any processor.</p>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/tabjllLuzNI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div id="sheas_container_1"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>
<p>Conduct a qualitative analysis of the full adder circuit similar to that done for the xnor gate in the previous lesson. What propagation delay do you estimate?
<a href="https://sheas.magiwanders.com/?chip=N4IgJgpgbglgxhAziAXKSUCMrQBsCGARhLqiAGYCuuuA%2BvmJAE60AMIANCAC4CeADhDIBlSoTgwmcSjG6cQ%2FJgHt%2B%2BAOb5uMJQDtUrLghp9BZKjXqMITefyWJZ2vWhAAPVACYA7AFYuvVABaHwBfEK4MDxwQAmJSFBB8eRMhBIAhSm5uXVtlVQ0tHJQDEB1KAFtCfERUkAALCHcuQllkFEwuHQg5BKSuOwdC51B3FB8SgJRAgDZWMIjoAGZo2JIyQmSBWoysnP689U0nfU6KqpqyBqaQFu42jtLu9dt7RyKR1HH%2FVEw58PBoAAWFZENYJOCbUzpTLZPT7FSHIYnUpnaq1K7yW73TpPcEvQbHFyjL4gSa%2BeYAqA%2BEFxMiICqQ2oAGXw5X4uQRBUJJTKlTRl0amNaPxxPRA9PK%2BLewzcqEBXgmnz%2BCyg0xpYJAcHwTCYAS4KTILLZHPyRyKPNRFwSGOawvaorIWp1eoUryRRLlCu%2BU0WoQpcF0XTg2SYbQA2qByMpJS4YGAyBhsP0lEwxRKQP9stE4wnoNTk6myDA9PNI9Hs%2FGEomXoXwdrdRn9UoK7nVTWxcWM%2BEy0oY6Ac1XoFEC2KlJlGzxm7HK5Sk67a4kuxwe32QAPKcsR2Qx3JM1P%2BzPq1uEhtSxRy9PW8DjyAdxOs5fB1h246uwBdLj08SSaR20Ap6IMHgJBAOgbAXFWeJF31LYyB2WETURblTj5K16kFW07hFR4xT6V0CXeWVim9ZVKSiCDQSgu8YKhEAjXZeFTXdC1UPRDCbjtB4ulHcdkwImVRkWAAORUUEWUiMGWCjaQSHR8B0MA2EZMgADl5PjRikKKB4sWw4t%2BEyNoPD46VolGTAPD8UlPgpDBgWkjU5IU2g5wNBI1IUxCuW0zDsTXHQDKwlBjPw0yPXaSzvR8P0VWpByoI2GjthhPYFAObznBY842OuXT7Rw54TPdD5iOslBZls6A1XisgnMU4ceFg9z1K8s1nB0ziuH0wzPCKwkSssqzJnEsJ%2FgDHQgxDcMVxbJ85zsBc7z3WaNxfBJi2wM8o17FaMDVG8lqbXahzW%2Fylxmx9KXzeceN3I7Lrs07iyiLaLwPVtroW27733NdDyBJ6dE27tzx2h6wNOw7J2OqBNxuosdBekHttXddJMh8dlvBtsbw287QdR%2F6oGveGEihh93qffbSf8pG33%2BFqXCAhA2nQCGat6ZToV2OE0s5NrkV5bKBVyzqCs5vrCNGUSJJOjnb14xraPo1rmJQ4XrXYvKuNxBW5ElgS5V9b0Rv%2BdH5bqpSktUlrNIy7Dta6gKeuCg2zJ%2BY2ytNlV7LwSjavUlyuZADyNL5pjCQ6oKHm6oKQoGMKBpEk3ZapdUEuD%2BDUsUfm1ZRViRaFaOHRPKViqI0SKv9QMIGDFNpoJmH5pTb6scp1bcaB%2FGUZhz6W%2B3TH7vb9HO6R5dG%2BxuGvoHu7oexknp%2FWrvXrB4elgx2eKb%2Bq9AbHi61%2BJjefphhrF7OsJ6c6JQejZ2AWdA595c7a3uYQu2BdKoX%2BU10Xi%2FFs63bhRlpVKA5E%2FYyT1sHFW7885fzQjaDif9uIzzLv1Ii3ghr6BAVJcBjlA7sBfiHW24ctLtV8npZ2cdAElQspg4oo1DA1zrqGVAEYJ4Hynv3Mmg854H1Plw8%2ByM3rbzmkfNuIiO40zxivQmrZm6LR4VvNG69R7vn%2BK4ACTNoDAVZrOdO24WAEKVrUUQ34pAyH1iQ%2B2pUjC4DcreGw1CiI%2BE9pMQEMUyL6N6M5Ix9jTESHMbIVWyFNQkDsU1RInknGCS9GVDx5tcFQUDq5CJ%2FifwWOCeaQwYT7HEITuXGJokhLxIBhba%2BVtjEiDEAE38lic4RyyaE4wESdDX1QVLH4sxvSWRAXFRJtVykpNomkwJdT0ofxKLY%2BxrS6lujQeZLpZURIgOqv0iWlTX7Z3GbAy0OUi5%2BWQes%2FJ8zkSTGCCArwXibiZxSrzeppDBa7MLuQ%2FKhzrnRNOT8VgqchJXJ3BU%2Bx0CrETPVt%2FdCv8Dm62oqFApqBpjFKin8MaTCpqsP3hIvaYih4YoBp3buwjlFQEuQdRRv1CV9wXJ2GRvcsW8JxaA06p4hGr3pdTM%2B5MyVE34QuJI1LsbEpphymGnCFxMvHj3eetKlFExFbhfFLLCWypQeIwl8ixRivRYS7lrdsWqtOry5lsjREks3py1svy8UX3%2BHUfAuByCWGYA%2FHRD9wJrOghskAWc7nbJCXAvZLydZyo%2BaVSYqcwExH9qXQhXrMmZVBfArWYs3mJRhSckNqAACcJTYZXPTIQoF9zrFZTBQgx2%2F882po6WJVgdDMDZt9hGiBToGz5tZAxYFOyC4%2F32dhN5zaXTHKreJOhxTelXI0YY4OIzamxuRFMiJE72mG3aNFKKKyrn4KndU9JQSYEhPnbRPJcyq11pHUixhE1a6opQGwiVB81XKt1UTClcq%2BV8KlWap8L7nhvvpQ%2B7hpqYZsoEQa8VBKuUfqA4y%2BVRrKTAYUYByVlrDU0pNcfSegM1FcHMHQBgjqtF3xAgR11jaNQpgBak7dozZ02JyREgCwbhKiUCBZMNVybV2oddYCjwyqMzr3Y0g96JbX2rw9YJd7sxJ0JYx4VOODSNQQ46JqwLAhkmL4xkgTcamnhNokprjjjK3Lo8JFMqLHvkgIbZBMgeF7Exq048rt4Ke2vN1nhQdy7zPMcwO4sd8sU12duTR4tCaIW9t1imjzkmvPekCKOs2VUrkQmjUFhzn8nndoDSXTUEnwoxbMz0hLRLc0MlbcaNLIX%2FWIMhWmUrRnJMuOY9MbNvz5b9qgW24L8aqtlr7fWAdx7l2Ndi5gOtDDNQovrmi9hf7IPYwtVIksKHsbarpAyFVMr9UweFaddMG3WwCrPlS5bB8F4CKFStrbv7yVzffTeDVM3CXwZ1XSxV0HrubZvO1%2FbxqaYPbvfS1bdZnTofvVdkI9MwhAA%3D" target="_blank">Here is an isolated full adder circuit, of which there are many inside the incrementer.</a></p>
</li>
<li>
<p>Does the overall propagation delay of the incrementer chip change for different inputs? If yes, with which criteria?</p>
</li>
</ol>
<h2 id="transcript-1"><a class="header" href="#transcript-1">Transcript</a></h2>
<p>When logic gates are studied, there are usually two different ways to communicate their functionality. </p>
<p>One is the truth table, that is the complete list of outputs given the list of all the possible combinations of inputs. Some examples of this are the nand gate, the truth table of which shows the output only deactivating when the inputs are both on, or the xnor gate, whose output is active only when the two inputs have the same value. The other way of communicating functionality, is the way we just used to describe the truth table of the first two gates, that is a functional description in plain english. This is often preferred for the sake of brevity with gates that have many possible inputs, but a simple rule to calculate the output: this is the case of the incrementer chip here, which has 256 possible inputs, since the input port is 8 bits wide, but its output can simply be described as &quot;the input plus one&quot; for any given input. </p>
<p>Whichever way the gates were described with, there is one further detail that is often omitted or quickly touched upon and not really cared about: the output of each gate is always calculated with a small but measurable delay, with respect to the input variation. This is called propagation delay. Thankfully, this tool is granular enough to show it. </p>
<p>Inspect the inputs and the output of the nand gate and then pause the simulation. Zoom in on the monitors so that you can comfortably see each step. Now let us fiddle with the inputs, and try to understand how many steps it takes to calculate the output given any input variation. It takes one step, and you can verify all the combinations by yourself. </p>
<p>How long one step is is rather unimportant, it might be one millisecond or one nanoseconds, for our purposes that is not important: it is the smallest time division of the engine of our simulator, and might as well be the smallest time interval we can measure with a logic analyzer, in the real world.</p>
<p>We can do the same with the xnor gate. We notice that sometimes the output takes five steps to propagate, as it is the case with inputs changing from zero zero to zero one, and sometimes six steps, as it is the case with inputs changing from zero zero to one one. We can therefore say that the propagation delay of the xnor is six steps. Why then is this value higher than the propagation delay of the nand gate? Let us remember that the nand gate is what is called a universal gate, which means that it can be used to synthetize any other logic gate, like this xnor here, that just so happens to be synthetized out of nand. The longer propagation delay of the xnor, is therefore directly proportional to the complexity of its implementation in nand gates, and we have also verified it being variable with previous input. </p>
<p>Let us spend two minutes for a qualitative analysis, of how the inner structure of this xnor chip results in the propagation delay we observed. We see the inner structure being made of 'and', 'not' and 'or' gates. Internally the not is made of a single nand port with shortcircuited inputs, which means that its propagation delay is the same, one step. The and gate is made of two nand gates in series, so it is rather intuitive that its propagation delay will be two steps. The same can be said about the or gate, which has a maximum of two nand gates in series between any of the inputs and the output. The structure of the xnor gate is slightly more complex, but we only have to understand how to generalize the concept. Each input has two routes towards the output, one that is five steps long and one that is six steps long, as they both pass through a not gate, an or gate, an and gate and only one of the two passes through the first not gate. So without assumptions about the inputs, we can say that the maximum delay of the xnor gate is six steps.</p>
<p>Let us now consider the incrementer. You can see inspecting it that its a rather complex circuit, so we expect it to have a rather high maximum propagation delay. How much exactly? Let us set the input to decimal try some values. Zero to one takes 12 steps. 254 to 255 takes 4 steps. 127 to 128 takes many steps.</p>
<p>The exact propagation delay of this chip will be asked to you as an exercise, after this part of this lesson. I invite you to notice, that the carry of each full adder is given as input of the following full adder. You will be asked to reason about what that means for the total propagation delay and if, given this structure, the fact that one input of the adders is always one, somehow changes the delay estimate. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-of-register-transfer-level-rtl-abstraction"><a class="header" href="#review-of-register-transfer-level-rtl-abstraction">Review of Register Transfer Level (RTL) abstraction</a></h1>
<p>This part of the lesson covers the limitations that propagation delay causes to RTL.</p>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/wVtvX6spkls" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div id="sheas_container_2"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<h2 id="transcript-2"><a class="header" href="#transcript-2">Transcript</a></h2>
<p>In the previous lesson we learned about the propagation delay, which is an intrinsic characteristic of each logic gate. In this lesson we are going to cover the same topic at a slightly different abstraction level, the so called Register Transfer Level, or RTL in short. This is a design abstraction, that focuses on sampling the inputs and outputs of a circuit with registers, as you can see in the simulation below, which contains the same chips as the last one but with sampled inputs and outputs. You will hopefully understand how this abstracted structure, is all over the hardware architecture of processors. </p>
<p>Now let us explore how this new abstraction level influences how the chips work. For this we focus on the nand gate: please pause the simulation and inspect its clock signal, and the input and outputs on both sides of the registers. When an input changes, it is not passed to the inner circuit, in this case the nand gate, until the next rising edge of the clock signal, which updates the input registers' ouputs after one step. After that the nand gate is free to propagate and calculate its output in one step: such value is however not immediately transfered to the actual circuit output, it will do so only at the next rising edge of the clock signal, which will update the output register, that after one further step will update the actual circuit output. Given that the input is detected at a given rising edge of the clock signal, the ideal case is when the correct output, comes out of the output register at the very next rising edge of the clock signal, that is when the propagation delay of the circuit contained within the input and output registers is shorter than the clock period. This is critically important: if we want for example to put more than one of this cells in series to one another, each one must compute its own output within one clock cycle, that is the rising edge of the clock signal immediately after the one that detected the new inputs, in order sample the correct output. If this does not happen, the wrong value is passed onto the next section of the circuit and the computation fails.</p>
<p>This being said, we can now see the propagation delay of a chip under a different perspective: it becomes a limit, to the maximum clock frequency that the corresponding RTL representation can handle without error, where by error we mean the output being sampled at any later point, than the rising edge immediately after the one that detected the different input. We can call this limitation a &quot;sampling constraint&quot;.</p>
<p>Let us try then to find the maximum clock frequency of each of the circuits in the simulation panel. The clock component can be controlled by the number above it, which represents how many steps until the clock changes value, or half of the clock period as measured in steps. So, for example two consecutive rising edges of a clock set at number 5 are 10 steps apart, and that value, the clock period of 10 steps, is the maximum allowed propagation delay of the chip contained inbetween the registers, that are clocked by such signal. </p>
<p>Let us then tackle each circuit. We found out earlier that the propagation delay of the nand port is just one step. Therefore even a clock set to 1, which has a two long clock period, should present the correct output after just one clock cycle. Let us verify that. We see that no matter when we change the input, the output changes exactly one step after the next rising edge, to the one which detected the new input. The extra step is due to the propagation delay of the output register itself.</p>
<p>We can do the same thing with the xnor, expecting the minimum clock period to be 6, that is the clock component set to 3. The way to test the worst case scenario is to use one known input, with the maximum expected propagation delay, in our case zero zero to one one, and change it at the same time as a rising edge of the clock. We see that even in that case, the circuit still functions properly.</p>
<p>Regarding the incrementer, it was your task to find its exact propagation delay in the last exercise, so we are not going to spoil the solution. We are therefore going to use this chip as an example of what happens if you got your estimate wrong. If you overestimated the delay you are not going to see the error with the signal monitors, as the correct output will just wait to be sampled at the output register for a few steps. If you underestimated the delay however, it will be very evident from the signals, and that is the case we are covering now. </p>
<p>Let us say that you estimated the propagation delay of the incrementer to be 20 steps (we are taking a particularly low estimate just to be sure that it is very very wrong). That means that we expect that a clock set with number 10 will sample the correct output, at the rising edge immediately following the one that detected the new input.</p>
<p>Let us set the input radix and the monitors to decimal and the clock to 10. If we set the input to zero, and the change is detected at this rising edge, we can see the circuit comfortably outputting one just one step after the next rising edge. Remember that that extra step is due to the propagation delay of the output register.</p>
<p>However, if we input for example 63, we see that the next rising edge yields 56 instead of 64. What is more is that the next rising edge is sampling the value 32, again instead of 64. Finally, on the third rising edge after the one that sampled the new input we get 64. This behaviour happens because the propagation delay of the incrementer with input 63, is between 40 and 60 steps (between the second and third rising edge from the one that sampled the input) and at each rising edge before the result is ready, the output register is sampling some random number that comes out of the incrementer chip, while it is propagating. This is in a nutshell why in general, the clock period must be slow enough to allow for the full propagation of the circuit at any input. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-diagram-for-graphing-the-dynamic-behaviour-of-rtl-circuits"><a class="header" href="#a-diagram-for-graphing-the-dynamic-behaviour-of-rtl-circuits">A Diagram for Graphing the Dynamic Behaviour of RTL Circuits</a></h1>
<p>This part of the lesson introduces a simple diagram for representing the time evolution of the execution of a circuit at Register Transfer Level.</p>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/MSB_ssEwkBc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div id="sheas_container_3"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<p>Use the table below to generate the diagram:</p>
<table class="table">
  <thead>
    <tr>
        <th>Input</th>
        <th>Cycle 1</th>
        <th>Cycle 2</th>
        <th>Cycle 3</th>
        <th>Cycle 4</th>
        <th>Cycle 5</th>
        <th>Cycle 6</th>
        <th>Cycle 7</th>
        <th>Cycle 8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th><div><input size=2 type="string" id='2.5.1.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.9.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.9' onchange="save_table(event)"></div></th>
    </tr>
  </tbody>
</table>
<p>Daily activity of a 24/7 laundry.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Hours</th><th style="text-align: center">8:00-13:15</th><th style="text-align: center">13:15-18:30</th><th style="text-align: center">18:30-23.45</th><th style="text-align: center">23:45-5:00</th><th style="text-align: center">5:00-10:15</th></tr></thead><tbody>
<tr><td style="text-align: center">Client 1</td><td style="text-align: center">Wash+Dry+Iron</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 2</td><td style="text-align: center"></td><td style="text-align: center">Wash+Dry+Iron</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 3</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Wash+Dry+Iron</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 4</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Wash+Dry+Iron</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 5</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Wash+Dry+Iron</td></tr>
</tbody></table>
</div><details>
  <summary>The solution, for a laundry business.</summary>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Hours</th><th style="text-align: center">8:00-10:00</th><th style="text-align: center">10:00-12:00</th><th style="text-align: center">12:00-14:00</th><th style="text-align: center">14:00-16:00</th><th style="text-align: center">16:00-18:00</th><th style="text-align: center">18:00-20:00</th><th style="text-align: center">20:00-22:00</th></tr></thead><tbody>
<tr><td style="text-align: center">Client 1</td><td style="text-align: center">Washes (and waits 15 min)</td><td style="text-align: center">Dries (and waits 30 min)</td><td style="text-align: center">Irons</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 2</td><td style="text-align: center"></td><td style="text-align: center">Washes (and waits 15 min)</td><td style="text-align: center">Dries (and waits 30 min)</td><td style="text-align: center">Irons</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 3</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Washes (and waits 15 min)</td><td style="text-align: center">Dries (and waits 30 min)</td><td style="text-align: center">Irons</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 4</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Washes (and waits 15 min)</td><td style="text-align: center">Dries (and waits 30 min)</td><td style="text-align: center">Irons</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Client 5</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Washes (and waits 15 min)</td><td style="text-align: center">Dries (and waits 30 min)</td><td style="text-align: center">Irons</td></tr>
</tbody></table>
</div></details>
<style type="text/css">
   input {font-weight:bold;}
</style>
<script>
    for (var i=1; i<10; i++) {
        for (var j=1; j<10; j++) {
            var id = '2.5.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) { localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script>
<h2 id="transcript-3"><a class="header" href="#transcript-3">Transcript</a></h2>
<p>Let us now introduce a way to graph the dynamic behaviour of RTL circuits. The only difference between the circuit below and the previous ones, is that this executes two operations within the two registers: an exponentiation to the power of two, and an increment. Therefore, given input 'x', we expect output to be 'x' to the power of two, plus one. Note that the multiply chip does not feature the whole circuit down to nand gates, as it would be extremely complex: it 'cheats' with an ad hoc component and an artificial fixed propagation delay. </p>
<p>The graph has the cycles on the x axis, that are read from left to right, and the inputs given to the circuits on the y axis, that are read from top to bottom. In a nutshell, it keeps track of which input was being processed by the circuit at each cycle. At the crossing between the cycle and the input we are considering, we write the operation that has been carried on that input in that cycle.</p>
<p>Let us now compile the graph while manually advancing the simulation. Let us pause it, inspect the clock signal, the input and the output, and enable the registers. Let's set the first input at zero, write it in the table, and advance by one clock cycle. We will see that though the input has been sampled by the rising edge of the clock, the output has not updated yet, as it will at the next rising edge. Remember that we consider the beginning of a clock cycle as its rising edge, and the end of it at the step just before the next rising edge. </p>
<p>At this point the operation of the circuit has been done on the first input, that is exponentiation and increment, so we write it down under cycle 1. We can therefore write the new output, let's say 5, and advance by one cycle.</p>
<p>We can see the result for the first input being sampled, and we can compile the diagram with the operation at cycle 2. Then we start over again. New input, write the input in the table, advance one cycle and write the operation on the table.</p>
<p>After a few steps we have a compiled table, that we can read in the following manner. What operation was done to input of value 5 in cycle 2? We can read exponentiation and increment. What operation was done on input of value 12 at cycle 4? We here read none. The reason why we have values only on the diagonal, is because the present circuit can only process one input at the time, which means that each input is processed in one clock cycle from beginning to end. For now, let us keep how this diagram is constructed in mind, but let us not forget the original topic: that of propagation delays and the constraint they set on the clock speed. </p>
<p>Imagine being the engineer who designed this circuit,and that wants to process inputs faster. How can we modify the RTL circuit so that it maintains functionality but speeds calculations? Let us try to get to an answer with an analogy.</p>
<p>Imagine being the manager of a laundry business open 24/7, which offers a washing machine which takes 1.45 hours to operate, a dryer which takes 1.30 hours and an ironer which takes 2 hours. One client comes in, uses the room with the three machines and then leaves, much like one input of the circuit above, which enters the input register, is processed, exiting from the output register. With this organization each client keeps the room busy for 5.15 hours, and we can see a diagram similar to what we compiled before, in which each time frame contains the entire cleaning process of only one client. How then can we optimize the profits of the laundry business?</p>
<p>The simplest solution is the most intuitive: letting three clients use the three machines at the same time in a linear fashion, that is a client starts using the next machine in the cleaning process, when the previous client finishes using it. This means that the clients proceed to the next machine with the same frequency as the slowest, in this case every two hours, because of the ironer. Each client therefore completes the cleaning process in 6 hours instead of 5.15 hours, but the laundry processes one client every two hours instead of one every 5.15 hours. You can see how the diagram transforms: now, time frames are much smaller, each contains up to three different clients at the three different stages of the cleaning process, and processing the same amount of clients takes therefore way less time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-pipelined-processor"><a class="header" href="#introduction-to-the-pipelined-processor">Introduction to the Pipelined Processor</a></h1>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/CuCSKILjSnM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div id="sheas_container_4"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<p>Here is the table to compile to create the diagram:</p>
<table class="table">
  <thead>
    <tr>
        <th>Input</th>
        <th>Cycle 1</th>
        <th>Cycle 2</th>
        <th>Cycle 3</th>
        <th>Cycle 4</th>
        <th>Cycle 5</th>
        <th>Cycle 6</th>
        <th>Cycle 7</th>
        <th>Cycle 8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th><div><input size=2 type="string" id='2.6.1.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.9.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.9' onchange="save_table(event)"></div></th>
    </tr>
  </tbody>
</table>
<p>Here is a program to use in order to write a simple diagram for the single cycle processor:</p>
<ul>
<li>Program:</li>
</ul>
<pre><code class="language-assembly">sw t1 0(t2)         # M[0xbc] = 0x123
LOOP:
   lw a1 0(t2)      # a1 = M[0xbc] 
   add a2 a1 a1     # a2 = a1+a1
   sw a2 0(t2)      # M[0xbc] = a2
   blt a2 a0 LOOP   # jump if a2&lt;a0
</code></pre>
<table class="table">
  <colgroup>
      <col span="1" style="width: 20%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
      <col span="1" style="width: 10%;">
  </colgroup>
  <thead>
    <tr>
        <th style="width:70%">Input (instruction)</th>
        <th>Cycle 1</th>
        <th>Cycle 2</th>
        <th>Cycle 3</th>
        <th>Cycle 4</th>
        <th>Cycle 5</th>
        <th>Cycle 6</th>
        <th>Cycle 7</th>
        <th>Cycle 8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>sw t1 0(t2)</th>
      <th><div><input size=2 type="string" id='2.6.1.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.9.1' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th>lw a1 0(t2)</th>
      <th><div><input size=2 type="string" id='2.6.2.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.9.1' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th>add a2 a1 a1</th>
      <th><div><input size=2 type="string" id='2.6.3.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.9.1' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th>sw a2 0(t2)</th>
      <th><div><input size=2 type="string" id='2.6.4.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.9.1' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th>blt a2 a0 LOOP</th>
      <th><div><input size=2 type="string" id='2.6.5.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.9.1' onchange="save_table(event)"></div></th>
    </tr>
  </tbody>
</table>
<p>Here is a cheatsheet that compares the case of the laundry to the processor. This is helpful to remember the core concepts.</p>
<div class="table-wrapper"><table><thead><tr><th>CONTEXT</th><th>24/7 Laundry</th><th>Single Cycle Processor</th></tr></thead><tbody>
<tr><td>THING TO PROCESS</td><td>CLIENT</td><td>INSTRUCTION</td></tr>
<tr><td>STAGES OF PROCESSING (fake timings)</td><td>Wash 1.45h, Dry 1.30h, Iron</td><td>Fetch 4ns, Decode 1ns, Reg read 4ns, Execution 5ns, Memory 6ns, Writeback 3ns</td></tr>
<tr><td>WHO ARE WE</td><td>Owners and Managers</td><td>R&amp;D Engineers, with the task to make the processor faster</td></tr>
<tr><td>CONSTRAINT</td><td>Only one client in the room at any given time. The laundry serves one client every 5.15h -&gt; 4.36 clients a day</td><td>Only one instruction in the processor at any given time. The processor serves one instruction every 23ns -&gt; 43.478.261 instructions per second (~43.5 MHz)</td></tr>
<tr><td>SOLUTION</td><td>Let three clients in the room at any given time, each using one machine and waiting for the next machine to free before using it (every two hours, the time of the longest task).</td><td>Divide the hardware of the processor in stages, one for each sub-operation, with interstate registers, which are clocked every 6 ns (time of the longest task)</td></tr>
<tr><td>CONS</td><td>Clients waits 15 minutes after washing before drying, and 30 minutes after drying before ironing, since ironing is the longest task. Each client takes 6 hours instead of 5.15 h to was the clothes.</td><td>Every stage except the slowest one will stall for some time after propagating, since they have to wait for the memory stage, the slowest, to finish so they can all proceed. Each instruction takes more to process five times the longest delay (5x6=30ns) instead of the sum of delays (23ns)</td></tr>
<tr><td>PROS</td><td>The laundry processes one client every 2 hours, time of the slowest stage, instead of 5.15, sum of all stages, as three clients at a time are in the laundry IN PARALLEL. The laundry serves 12 clients a day instead of 4.36</td><td>The processor serves one instruction every 6ns, time of the slowest stage, instead of 23ns, sum of all the stages, as five instructions at a tmie are in the processor IN PARALLEL. The processor serves 166.666.667 instructions per second (167MHz instead of 43.5MHz)</td></tr>
<tr><td>TRICK</td><td>No three clients are processed in a block, then 3 others in a block and so on. 3 Clients are there in any given moment, but they rotate (first in is first out)</td><td>No five instructions are processed in a block, then 5 others in a block and so on. 5 Instruction are there in any given moment, but they rotate (first in is first out)</td></tr>
</tbody></table>
</div><style type="text/css">
   input {font-weight:bold;}
</style>
<script>
    for (var i=1; i<10; i++) {
        for (var j=1; j<10; j++) {
            var id = '2.6.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) { localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script>
<script>
    for (var i=1; i<10; i++) {
        for (var j=1; j<10; j++) {
            var id = '2.6.' + i + '.' + j + '.1'
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
</script>
<h1 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h1>
<ol>
<li>You found out during previous exercises a qualitative estimate of the maximum theoretical propagation delay of the Incrementer circuit. You may have noticed that the circuit is actually a 8 bit adder with one &quot;hidden&quot; input set to one. Did this influence your estimate of the total propagation delate? Discuss the difference in expected actual propagation delay, if any, between a normal adder and the incrementer.</li>
</ol>
<h2 id="transcript-4"><a class="header" href="#transcript-4">Transcript</a></h2>
<p>In this part of the lesson we will explain, how the solution for the analogy of the laundry generalizes to the problem of the simple RTL circuit, from the last part of the lesson, and what all of this has to do with processors and how to make programs run faster on them.</p>
<p>How the analogy maps to the simple RTL circuit is rather straightforward: the clients map to the inputs of the circuit, and the machines map to the operations the that circuit executes on them. Letting each client use a different machine corresponds to dividing the circuit in two, with one further register, as shown in the circuit below, yielding a two-stage circuit which is able to effectively run faster, as the clock only has to wait for the propagation delay of the slowest of the two operations instead of waiting for the sum of their propagation delays. Just as each single client takes more overall time to process its own business, each input now takes longer to come out the other side, twice the slower component time, but the overall throughput of the circuit increases. Feel free to try for yourself for a given input to the circuit the version with only one stage, and two registers, and the new version below with two stages and three registers,and notice, that you can allow a faster clock with the latter.</p>
<p>Let us therefore see how to draw the diagram for this case. Let us use the same inputs as last time, therefore 0, 5, and 12. Let us write them down.</p>
<p>Inspect the clock and all the chain of signals, set the input, output, and all monitors to decimal, and pause the simulation. </p>
<p>Set the input to zero and advance the simulation by one clock cycle. We will call this, cycle one. You can see that the input zero has propagated in all the exponentiation stage of the circuit. Therefore, we can say that in cycle one the input zero was processed with the exponentiation.</p>
<p>Set the input to five and advance the simulation by one clock cycle. Now the input zero has passed to the increment stage, while the input five is in the exponentiation stage.</p>
<p>Set the input to twelve and advance the simulation by one clock cycle. We can see now that the input zero has finished processing, and the output shows the result one. Both the other inputs have behaved similarly, shifting to the right, with the 5 input now being incremented and the 12 input now being exponentiated.</p>
<p>Let us do one more cycle. Set the input to 7 and advance the simulation by one clock cycle. The output now shows twenty six, the result of input 5, while the incrementer is processing the input 12 and the exponentiator is handling the input 7.</p>
<p>We could go on indefinitely in this fashion.</p>
<p>The question is now, what does this have to do with the processor? As a matter of fact, the circuit that exponentiates and increments its input was also an analogy for a processor: a series of operations (read and write the memory, alu operations et cetera) that are executed on an input (an instruction) and that are synchronized by a clock signal, in a Register Transfer fashion. The very same diagrams that we compiled for the laundry and for the circuit, we can compile for a processor.</p>
<p>We made this whole journey, that started with remembering that logic gate operate with a propagation delay, to reach this point: processors are made of a very large number of those ports, and their cumulative delay becomes very noticeable with so many of them in series. It is the objective of the hardware engineer, to explore the ways to make it process more instructions in the same amount of time, preserving funcionality. Having already seen the solution in other analogic domains, it is just a matter of understanding how the principle generalizes to the processor. </p>
<p>The diagram for the single cycle processor is very simple, as only one instruction can fit inside it at any given cycle. Below is an example of a simple program. Let us use the acronym &quot;SC&quot; for cingle cycle to indicate all the operations, that the single cycle processor executes on the input instruction. In the first cycle, we expect the first instruction to be processed, in the second cycle the second instruction and so on until the end of execution. In case the branch is taken once, cycle six will contain the load, and the execution continues as before. </p>
<p>Now, the main question that we are going to answer in this lesson is, how to modify the hardware in order to process more instructions in the same amount of time?</p>
<p>Just as in the two previous analogies, the objective is to divide the single cycle processor in multiple so called stages, separated by interstage registers, so that each contains one instruction completing one well defined part of the total execution. This way, just as the laundry allowed for three clients at any given time working in parallel, on different stages of the cleaning process, the so called &quot;pipelined&quot; processor will allow multiple instructions being processed, at any given time, each completing one different stage of its processing. Both in the case of the laundry and in the case of the RTL circuit however, we did not have to identify the various discrete operations in which to divide the process, as they were trivial. How to sort the components of the single cycle into functionally defined clusters, and therefore how to divide the processor with registers, how the stages interact with one another and with each type of instruction, are all topics of the next parts of the lesson.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-pipelined-processor"><a class="header" href="#building-the-pipelined-processor">Building the Pipelined Processor</a></h1>
<p>We are now going to build the pipeline, but we are going to use another simulation program: Ripes. Below you'll find a guide to download it and use it.</p>
<h2 id="ripes-setup"><a class="header" href="#ripes-setup">Ripes Setup</a></h2>
<h3 id="virtual-machine-setup"><a class="header" href="#virtual-machine-setup">Virtual Machine Setup</a></h3>
<ul>
<li>Download the virtual machine containing Ripes <a href="https://drive.google.com/uc?export=download&amp;id=1MIDXYVtsaYKxCYUdW-lFQ8cbkSl-Truh">HERE</a> (the file <code>comparch.ova</code> is relatively big at ~2.7GB)</li>
<li>Download and install <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank">VirtualBox</a> for your system.</li>
<li>Open VirtualBox and import the file <code>comparch.ova</code>:
<ul>
<li><code>File &gt; Import Appliance</code></li>
<li>Select the file <code>comparch.ova</code></li>
<li>Click <code>Next</code>, click <code>Import</code></li>
<li>A new Virtual Machine should appear in the main window. Double click for booting it up.</li>
</ul>
</li>
</ul>
<h3 id="important-info-on-the-virtual-machine"><a class="header" href="#important-info-on-the-virtual-machine">Important Info on the Virtual Machine</a></h3>
<p>The information that follows is not directly useful for the lesson but might be needed when operating the virtual machine:</p>
<p><strong>Some Ripes sub-windows, like the Pipeline Diagram one, DO NOT have the 'x' button to close them. Use the 'Esc' key.</strong></p>
<ul>
<li>The virtual machine only shows the <code>Ripes</code> program, which opens at startup. It will be needed in the second part of the lesson.</li>
<li>Verify that the copy and paste functionality works between the host and the guest (it is simply easier to copy programs from this site to within <code>Ripes</code>).</li>
<li>Login credentials: 
<ul>
<li>user: <code>student</code></li>
<li>psw : <code>student</code></li>
</ul>
</li>
<li>System: <code>Manjaro Linux i3 minimal updated september 2022</code>. Any modification or update is strongly advised against to preserve functionality.</li>
<li>How to open a terminal:
<ul>
<li><code>Alt+2</code> </li>
<li><code>Alt+Enter</code></li>
<li>The terminal is a standard linux terminal. If one desires to modify the i3 configuration, one has to modify the file <code>~/.config/i3/config</code> for example with the <code>nano</code> editor:
<ul>
<li><code>sudo nano ~/.config/i3/config</code></li>
</ul>
</li>
</ul>
</li>
<li>To return to Ripes in any moment:
<ul>
<li><code>Alt+1</code></li>
</ul>
</li>
<li>If for any reason <code>Ripes</code> closes, reboot the virtual machine.</li>
</ul>
<h2 id="ripes-tutorial"><a class="header" href="#ripes-tutorial">Ripes Tutorial</a></h2>
<iframe width="854" height="480" src="https://www.youtube.com/embed/fYGnEghKAKI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="transcript-5"><a class="header" href="#transcript-5">TRANSCRIPT</a></h2>
<p>This tutorial is an unofficial Introduction to Ripes two point two point three.</p>
<p>RIPES is a graphical processor simulator and assembly code editor for educational purposes. It was written by Morten Petersen. The program itself is theoretically architecture agnostic, but we can see in the processor selector that it currently only offers RISC-V single stage, pipelined and dual issue processors. Each processor has an extended layout for more visualization detail and settings for extensions or register initialization.</p>
<p>Onto the prorgam itself, the EDITOR TAB contains the tools to program in assembly. Programs are loaded via File&gt;Load Program. It is currently biased towards RV32I (and depending on the processor M/C) assembly. On the left hand side actual assembly can be written (or C if you link a RISC-V compiler in the settings). On the right hand side is the machine code in hex, disassembled or binary form.</p>
<p>The execution of a program can be controlled either step by step (forwards and also backwards in time), or setting a clock time and then pressing play. The execution can be reset or played without updating the ui for faster execution. If executing on a pipelined processor, on the right hand side of the editor tab it is displayed what stage the instruction is currently in.</p>
<p>The PROCESSOR TAB contains the hardware visualizations. The visualization itself is very intuitive: wires' can be highlighted for reading their path better and their value can be accessed by hovering (and can have any radix) (if they are 1 bit wide they are colored green when value is 1 and grey when value is 0, if they are multibit, they just flash yellow if updated at a given clock and remain grey if not updated). The selected option of muxes is colored green and a similar visualization is used for useful indicators, like branch taken. The other components tend to be self explanatory, by naming I/O explicitly.  CTRL+Scroll  is for zooming. On the right the register file is displayed. Values can be edited manually. Pipelined processors show the currently processed instruction above each stage. </p>
<p>The layout can be changed if needed. Just unlock it from outside the visualization square, and modify at your wish. At any point you can save the layout as json file by right clicking on the visualization square. Saved layouts can be loaded back only when layout is unlocked by right clicking on the visualization square. </p>
<p>On the bottom right is the instruction memory which for each instruction offers the possibility to insert breakpoints, other than again giving information about address and current stage. Here some statistics are given: Number of cycles, retired instructions, CPI, IPC, clock rate. Here is the console that prints ecall print functions. Finally, the table button brings up the pipeline diagram at the current cycle.</p>
<p>The visualization is easier on the eyes in view &gt; dark mode and all values can be shown or hidden under view &gt; show processor signal values.</p>
<p>Under the MEMORY tab the whole Data Memory can be accessed, either by scrolling or with the goto options below. </p>
<p>Cache and I/O tabs are used for, well, studying cache and Input/Output but the detail for those is for another video. </p>
<p>All of the processor designs can be modified in the source, for example for modifying the hazard unit of the 5 stage pipelined 32 bit processor one can modify the src/processors/RISC-V/rv5s/rv5s_hazardunit.h. The hardware description language is VSRTL, a domain specific language embedded in C++ by the same author. After modifying, Ripes has to be re-compiled. See instructions in the github repositories, links in the description.</p>
<p>If you are not familiar with the pipeline feel free to skip the rest of the video and come back if you need :)</p>
<p>Taking as reference the visualization of a pipelined single issue processor design, the student can use three overlapping but different ”perspectives of focus” when studying and playing with RIPES: 
The stage view, or vertical view, focuses on checking if a given stage is modified by different kinds of instructions according to the students expectations: for the simplest example let us consider the IF stage. We expect thes hexes out of the instruction memory, and we can verify it when the corresponding instructions pass in in the IF stage. For the ID stage, we expect for example the add instruction to enable the write back flag and the store not to. We can again verify. For the EX stage and the add instruction, we expect the first input of the alu to be the content of the register 1, and we can verify it again. This was the stage or vertical view. 
The instruction view, or cross view, focuses on following the instruction along the pipeline to understand its impact. This is the same thing as the previous focus, just under another perspective. For example the student has to notice that in whatever stage the instruction is in, it &quot;drags&quot;' with it the values it needs as they were when the instruction was in the stage in which they were created. For example the PC here is the current value, here is the previous, which was current when this instruction was in IF stage et cetera. This was the instruction or cross view.
The pipeline view, or horizontal/global view, focuses on the evolution and global impact of signals within the pipeline: this is a combination of the previous two focuses. For example in the ID stage, the Write Register flag is produced here on the control unit and used here on the Register file, but there isn't any direct connection: it has to go all the way through the EX, MEM, and WB stages and come back to the ID stage, because it has to wait for the write data, that you see also coming from the WB stage, to be retrieved in the MEM stage in case of a load, or to be calculated in the EX stage in case of many other instructions. In each following stage the value of the write register flag is the that produced by the Control unit when the corresponding instruction was in the ID stage, so the value currently being used by the register file in the ID stage, which comes looping back from the WB stage, corresponds not to the one being produced by the instruction currently in the ID stage but to the one being produced by the instruction currently in the WB stage. So the instruction currently in WB is writing back to the register file only now, even if topologically the register file is in the ID stage and even if that same instruction already passed through it three cycles ago. The write register flag was ready then, but the data to write was not. So, the write register file had to be &quot;dragged&quot; along until the stage in which the actual write back was going to happen. This was the pipeline or horizontal or global focus. </p>
<p>That is all, thank you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grouping-the-components-of-the-single-cycle-processor"><a class="header" href="#grouping-the-components-of-the-single-cycle-processor">Grouping the Components of the Single-Cycle Processor</a></h1>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/nMIAv9rirRA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<div class="p2p_container" id='screenshots/single_cycle_standard.png'></div>
<table class="table">
  <thead>
    <tr>
        <th>Stage</th>
        <th>Which component are in this stage?</th>
        <th>Which signals come from the following stages?</th>
        <th>Which signals go towards previous stages?</th>
        <th>Which signals go into the interstage register towards the next stage?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>IF</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>ID</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>EX</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>MEM</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>WB</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
  </tbody>
</table>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<ol>
<li>Where in the groups we just defined are placed the components that were hidden in the standard visualization of the processor but that are shown in the extended visualization? Complete the table above with all the new components and signals.</li>
</ol>
<div class="p2p_container" id='screenshots/single_cycle_extended.png'></div>
<script>
    for (var i=1; i<6; i++) {
        for (var j=1; j<5; j++) {
            var id = '3.1.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) {localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script>
<h2 id="transcript-6"><a class="header" href="#transcript-6">Transcript</a></h2>
<p>It is now the time to build the actual pipelined processor. As we anticipated during the last part of the lesson, the point is to divide the components of the processor by function, and to divide the clusters with registers. Let us then start with a quick high level recap of the flow of the instruction in the processor. </p>
<p>The processor calculates the new program counter value, gives it as address input to the instruction memory, and retrieves the corresponding instruction. We will call this function &quot;Instruction Fetch&quot;, or 'I F'.</p>
<p>Then, the processor decodes the value of all its fields, which includes retrieving the values of registers from the register file. We will call this function &quot;Instruction Decode&quot;, or 'I D'.</p>
<p>Then the processor selects the correct inputs and the correct alu function, to make the calculation associated to the current instruction. The branch instructions will also use the Branch Comparison chip. We will call this function &quot;Execution&quot;, or 'EX'.</p>
<p>If applicable to the current instruction, the processor interacts with the data memory to either read it or write it (think the load and store instructions). We will call this function &quot;Memory&quot;, or 'MEM'.</p>
<p>Again if applicable, the processor writes the results of the Execution or of the Memory operations to the register file. We will call this function &quot;Write Back&quot;, or 'WB'. </p>
<p>Now let us build each stage, that is each of the new &quot;areas&quot; of the processor, constituted by the components grouped by function and divided by registers. In doing so, we can compile the table below, which keeps track of all components and connections for each stage.</p>
<p>The first area contains the components that perform the &quot;Instruction Fetch&quot; function, which means the Program counter register, the mux that selects its next value, the plus four adder and of course the instruction memory. The other chips, like the decode chip, are part of the next stages as they decode the instruction, not just fetch it.</p>
<p>Now that we have the components, we ought to recognize which signals go into the interstage register towards the next stage, which will be all the signals that are needed in the following stages of the processor, and which signals come from one of those following stages, which are usually needed when a signal that controls one of the components in a given stage, is calculated in one of the following stages. Since this is the first stage there will be no signal going towards previous stages, but those will be needed in the following stages when sending back, the signals that are calculated after they are needed. This will be more clear as we go along.</p>
<p>Of the outputs of the components of this stage, all three are needed in the following chips: the instruction signal is needed in the decode chip, the program counter signal in one of the alu operator muxes, the program counter plus four signal in the mux that selects the register file write data. They therefore all go into the interstage register, which since they are all 32 bit signals will be 96 bits wide. </p>
<p>Of the inputs of the components only one is not covered by neither the components themselves, nor signals coming from the previous stage, that is the input of the mux that selects the next program counter value linked to the alu result. For example, a branch instruction with its branch taken, needs the alu to calculate its branch address, to feed the program counter. This is an example of a signal that is calculated in a later stage and sent back to a previous one.</p>
<p>The second area contains the components that perform the &quot;instruction decode&quot; function, which means firstly extracting opcode and source register indexes, therefore we need the decode chip, secondly the value of said registers, so we need the whole register file, and finally the immediates if any, so we need the immediate chip.</p>
<p>Of the outputs of these components, all three are needed in the following chips: the two values of the source registers are needed as inputs of the alu, and of the branch comparison chip, as well as data memory for the source register 2, while the immediate is only needed as alu input. Note that since the program counter signal is not used here, it has just to be passed through towards the next stage. The same goes with the program counter plus four signal.</p>
<p>Of the inputs of the components, again only one is not covered by the components themselves, which is the register file data in, calculated all the way back at the last mux. This is calculated at the end of all other operations, because many signals can be written in a register: arithmetic operations instructions write the alu result, loads write the memory output, jumps write the program counter plus four signal. There is however one observation that has to be done: when writing the register file, the data in signal and the write index signal must refer to the same instruction. This is not an issue in the single cycle processor, as the whole processor is processing a single instruction at any given time, but what we are doing is dividing the processor into stages, so that each stage can contain an instruction, and therefore process multiple instructions at the same time. That means that being the register file and the mux that selects the data in in two different stages, when writing the register file the instruction that will be in the same stage as the register file will be different than the one that the data in signal refers to. How to make sure that the write index signal will also refers to that same instruction, and not to the one currently in the decode stage? </p>
<p>The solution is cutting the write index sigal and pass it on to the interstage register, towards the next stage, and pass it through all the stages until the same stage where the data in signal is calculated, to then be 'passed back' together with it. This ensures that the two signals refer to the same instruction, when writing the register.</p>
<p>This also means that although we are placing the register file in this decode stage, functionally it is also part of the same stage that calculates the data in signal, which we have still to build. We can say that the register file chip is part of the decode stage when reading from it, and part of the other stage when writing to it.</p>
<p>The third area contains the components that perform the &quot;execution function&quot;, that is the alu and the two muxes that select its inputs and the branch comparison chip.</p>
<p>Of the outputs of these components, the alu result and the value of source register two will go in the interstage register, towards the next stage, together with the write index signal and the program counter plus four signal, that are not used here. The alu result is also passed back to the fetch stage, where it is used as a possible next program counter value, as we already said. </p>
<p>Of the inputs of the components, all are covered by the components themselves or by signals passed from the previous stage, therefore no external ones are needed.</p>
<p>The fourth area contains the components that perform the 'memory function', which is just the data memory.</p>
<p>Of its outputs, the only one, the data out signal, is passed to the next stage, together with the alu result signal, that other than being used here as the address input of the data memory, is also used as input of the register file write data selector mux, and together with the write index signal and the program counter plus four signal, that are again not used here.</p>
<p>Of its inputs, both are covered by the signals coming from the previous stage, so no external ones are needed.</p>
<p>Finally we get to the last stage, consisting of the only remaining component, the register file write data selector mux, that simply passes its output and the write index to the decode stage to perform the write operation. Remember that functionally the register file is also part of this stage, as its write function is controlled from here.</p>
<p>We now have a rudimentary pipelined processor. In the next part of the lesson, we will briefly see how each type of instruction activates each of its stages.</p>
<p>As an assignment you will be asked to load the same processor on Ripes but with the Extended layout, notice all the chips and signals that were previously hidden, and place them in the correct spot in the various stages, completing the table.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-overview-of-how-each-inctruction-activates-each-stage"><a class="header" href="#an-overview-of-how-each-inctruction-activates-each-stage">An Overview of how Each Inctruction Activates Each Stage</a></h1>
<p>This part of the lesson explains how every stage is activated by each type of instruction. In order to do that we will use a simple list of unconnected instructions:</p>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/r7o8gau7_5I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="program"><a class="header" href="#program">Program</a></h2>
<pre><code class="language-nasm">lui a5 30
addi sp, s0, 4
srai sp, s0, 4
sub ra, sp, gp
blt x12 x10 -12
lw a1 4(t2)
sw a1 8(t2)
jal a5 30
</code></pre>
<p>Ripes will be used for the simulation.</p>
<h2 id="transcript-7"><a class="header" href="#transcript-7">Transcript</a></h2>
<p>We will now focus on how each type of instruction activates each stage. Please load the 5 stage pipelined processor without Hazard Detection and without Forwarding, in Extended mode, with no initializations, and copy the program in the editor tab. Let us now start the simulation and consider the fetch stage. </p>
<p>The fetch stage contains the circuit that calculates the next Program counter value, choosing between the current value plus four (which means fetching the instruction immediately following thecurrent one, as instructions are 32 bits, or 4 bytes wide) and the alu result, that for example holds the destination address of branch and jump instructions. Mind however that the signal that actually makes the choice is calculated in the execution stage. Therefore we can say that although topologically this circuit belongs to the Fetch stage, it functionally belongs to the execution stage, as that is where it is controlled from.</p>
<p>As for the instruction, in this stage it has not been decoded yet, so it has no semantic meaning for the processor. This means that each instruction is treated the same way: in this stage it is just this hex number. For each instruction we can verify that its hex code is matched, at the output of the instruction memory.</p>
<p>Starting from the decode stage, not all the signals will be used by each instruction. For example the load upper immediate instruction here does not feature source registers fields, and yet we see some values nonetheless. That is because those very bits that in other instructions decode into the two source registers here are are used for something else, the immediate. The processor ignores the values that have nothing to do with the current instruction, it just does not use them. Therefore, we will ignore them, but you have to know the Instruction Set to know what to ignore and what to check. This is particularly important because it is here in the decode stage, that all the signals that control the other stages are calculated.</p>
<p>Here on the right you see the cheat sheet that you can find at the end of the lesson menu.</p>
<p>For the 'load upper immediate' instruction we can check the address of the destination register, the immediate, which is shifted by 12 positions as per instruction specification, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled, since this instruction will eventually write to a register.</p>
<p>The write data select signal, which selects the alu result, which in this case will just contain a copy of the immediate.</p>
<p>Remember that the register file is being written later, from the write back stage, through the write enable signal, the write address signal, and the write data signal. This means that the Register File chip although topologically part of the decode stage, is functionally part both of de decode stage itself for its read function, but also of the write back stage for the write function. </p>
<p>The next five signals are only for memory and branch or jump instructions, so we ignore them.</p>
<p>The next three signals select the first source register and the immediate as alu inputs, and 'load upper immediate' as alu function.</p>
<p>We also ignore the last signal as it is used only by branch instructions.</p>
<p>Next cycle.</p>
<p>For the 'add immediate' instruction we can check the address of the source register 1, and destination register, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled, since this instruction will eventually write to a register.</p>
<p>The write data select signal, which selects the alu result, which in this case will just contain the sum of the immediate and the content of source register 1. </p>
<p>These three signals again select the first source register and the immediate as alu inputs and 'add' as alu function.</p>
<p>Next cycle.</p>
<p>For the 'shift right arithmetic' immediate instruction, the analysis is mostly similar to the last instruction, except for the alu function, which is 'shift right arithmetic'.</p>
<p>Next cycle.</p>
<p>For the subtraction instruction we can check the address of the source registers, and destination register. The analysis of the control unit is the same as the shift right immediate instruction, except the second alu input is selected to be the content of source register 2, instead of immediate, and the alu function is 'subtract'.</p>
<p>Next cycle.</p>
<p>For the 'branch less than' instruction we can check the address of the source registers, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is disabled, since this instruction will not eventually write to a register, or do anything really in the memory and write back stages.</p>
<p>We ignore the write data select and the three memory signals for this very reason. </p>
<p>We ignore the do jump signal, but we check the do branch signal being enabled.</p>
<p>The next three signals select the program counter and the immediate as alu inputs, and 'add' as alu function, as the alu will contain the destination address as a relative offset, from the current value of program counter.</p>
<p>The last signal selects 'less than' as branch comparison.</p>
<p>Next cycle.</p>
<p>For the load instruction we can check the address of the source and destination registers, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable, which is enabled since this instruction will eventually write to a register.</p>
<p>The write data select which is set to the memory output, as the value to be written to the register file will be the one retrieved from memory.</p>
<p>The next three signals instruct the memory not to write, but to read an entire word from memory.</p>
<p>We ignore the do jump and do branch flag.</p>
<p>The next three signals select the first source register and the immediate as alu inputs, and add as alu function, as the alu will contain the memory load address as a relative offset, from the value of the source register.</p>
<p>We also ignore the last signal as it is used only by branch instructions.</p>
<p>Next cycle.</p>
<p>For the store instruction the analysis is similar to the load, except the memory is instructed to write a word, instead of reading one.</p>
<p>Next cycle.</p>
<p>Finally for the 'jump and link' instruction we can check the destination register and the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable, which is enabled, since this instruction will eventually write to a register.</p>
<p>The write data select which is set to the Program counter plus four signal, as that is the value to be saved to the register file when a jump is done. The reasons have to do with how calls in operating systems are implemented, but this is a matter for another course.</p>
<p>We ignore all the next signals except the do jump flag, which is lit, and the three flags that select the program counter and immediate as alu inputs, and 'add' as alu function, as this is how the jump address is calculated, as an offset from the program counter.</p>
<p>This was all of the decode cycle. Onto the next stages, we are going to go faster as most of the functionality has already been decided.</p>
<p>The execution stage is where all actual calculations take place. This means either alu functions or branch comparisons. Note that here is also where the Program counter select signal is calculated, for controlling the program counter mux in the fetch stage. Now for each instruction we will see what these operations mean. Mind that these are not the only ones, but there is at least one representative of each major category.</p>
<p>The 'load upper immediate' instruction uses the alu, which has as inputs zero and the already shifted immediate. The alu function is 'load upper immediate', which simply passes the second alu operator, the immediate, to the output. That is the value that will be written to the destination register, x15 in this case.</p>
<p>Next cycle.</p>
<p>The 'add immediate' instruction also uses the alu, with inputs the content of source register 1, which is x8 in this case, and the immediate, in this case 4. The alu function sums the two, and the result is the value being written to the destination register, x2 in this case.</p>
<p>Next cycle.</p>
<p>The 'shift right arithmetic immediate' instruction uses the execution stage, just like the 'add immediate' instruction, besides the alu function which is 'arithmetic shift right', which shifts right with most significant bit extension, thus maintaining the sign of the operand. </p>
<p>Next cycle.</p>
<p>The subtraction instruction uses the alu, with inputs the two source registers, x2 and x3 in this case. The alu function is 'subtract' and the result is the value being written to the destination register, x1 in this case.</p>
<p>Next cycle.</p>
<p>The 'branch less than' instruction uses both the alu, the branch comparison chip and the program counter select circuit. The alu inputs are the prorgram counter and the immediate, which represent respectively the value of the program counter, from when the branch instruction was in the fetch stage, which is 0 ex 10 instead of the current 0 ex 18, and the offset from it that the branch is targeting, that is -12, or three instructions back. Note that saying &quot;the value of the program counter, from when the instruction was in the branch stage&quot; is the same as saying &quot;the instruction address&quot;. The alu function is 'add' and the result is the branch destination address. The branch comparison chip takes as inputs the comparison type, in this case 'less than', and the values of the two source registers. Its result is a flag that signals whether the comparison is satisfied or not. The name is 'branch taken' because when the comparison is satisfied the branch is considered taken, and the mux selector in the fetch stage must select the destination address. Let us then study up close the program counter select circuit, which is made of one 'and' and one 'or' gate. If we notice the names of the signals, we see that the resulting flag, the program counter select circuit, is activated only if, case 1, the instruction is a jump instruction, or, case 2, if it is a branch instruction with at the same time the branch being taken. If you initialized no registers at the beginning of the simulation, the branch should not be taken right now, as the values of both the source registers in input to the branch comparison chip are zero, thus the first one, x12, is not less than the second one, x10. Just for fun we can rewind by one cycle the simulation, and create a case in which the branch is taken, for example by setting the x10 register to the value 2. Now, back at cycle 6 we can see that the program counter selector is activated, and the next program counter value is going to be the current alu result, which is 4. Now go back again one cycle and reset x10 to zero, so we can see the next instructions passing by the stage.</p>
<p>Next two cycles.</p>
<p>Both the load and store instructions use the alu only, with inputs the content of the first source register and an immediate. The function is 'add' and the result is the address of the data memory that they target, just one for reading from it and the other for writing to it.</p>
<p>Next cycle.</p>
<p>Finally the 'jump and link' instruction uses the alu much like the branch instruction, therefore calculating the sum of program counter and an offset, but bypasses the branch taken signal, activating the program counter select flag, in order to jump with no conditions.</p>
<p>This was the execution stage. </p>
<p>The memory stage is only used by the load and store instructions, which are the only ones to interact with the data memory. You recognize the data memory not being used when the value of the memory operation flag is 'nop'. With the load instruction instead its value is 'load word', and with the store instruction it is 'store word'. For both we can use the Memory tab, to check that memory is being used correctly: in the case of the load, we can just check the value of the memory cell corresponding to the address, in this case 2, whereas for the store, we have to check that the input data, for this case zero, is written to the memory cell of the input address, in this case 8, but at the next cycle. This is due to the fact that, as any register based circuit, any memory shows its output one cycle after having received the input and the write flag.</p>
<p>Finally we come to the write back stage, which is only used by the instructions that write one of the registers, which we can recognize by the activated register file write signal. The exact register address is given by the write index signal.</p>
<p>The 'load upper immediate' instruction has the signal lit, so it writes the alu result, which in this case represents the shifted immediate. The write address is in this case 15.</p>
<p>In the next three cycles, the 'add immediate' instruction, the 'shift right arithmetic immediate' instruction and the subtraction instruction all do the same as the 'load upper immediate' instruction, with the alu result being the result of the respective operations.</p>
<p>Next cycle.</p>
<p>The branch doesn't do anything in the write back stage, and we can see the disabled register file write signal.</p>
<p>Next cycle.</p>
<p>The load instruction writes to the x11 register the output of the data memory.</p>
<p>Next cycle.</p>
<p>The store doesn't do anything in the write back stage, and we can see the disabled register file write signal.</p>
<p>Next cycle.</p>
<p>Finally the 'jump and link' instruction writes the program counter plus four signal, to the register 15.</p>
<p>With this the overview of the impact of each instruction of each stage is concluded.</p>
<p>Finally, let us see how to graph the execution of the program we just followed. Ripes does it for us with this button, but we have to know how to read the diagram. </p>
<p>Rewind the whole program. If we press the pipeline diagram button now, we can verify that the pipeline, at cycle zero, only contains the load upper immediate instruction, in the fetch stage.</p>
<p>If we do the same at the next cycle, we can verify that the pipeline, at cycle one, contains the load upper immediate instruction, in the decode stage, and the add immediate instruction, in the fetch stage. </p>
<p>If we do that one last time at the next cycle, we can verify that at cycle two, the load upper immediate instruction is in the execution stage and the other two instructions are in the two following stages. </p>
<p>The diagram is constructed like this for all following stages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="towards-hazards"><a class="header" href="#towards-hazards">Towards Hazards</a></h1>
<p>Finally, in the next two sessions we will see the dynamic execution of two simple assembly programs on Ripes.</p>
<p>Make sure you have read <a href="./0.1_setup.html">Setup</a> and <a href="./0.2_important_info.html">Important Info</a> in order to use the Ripes virtual machine properly.</p>
<h3 id="index-1"><a class="header" href="#index-1">Index</a></h3>
<ul>
<li><a href="./4.1_simple_meaningless_program.html">DEMO - Meaningless Program</a></li>
<li><a href="./4.2_towards_hazards.html">DEMO - Program Towards Hazards</a></li>
<li><a href="./4.3_assignments.html">Assignment on Hazards</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo---simple-meaningless-program"><a class="header" href="#demo---simple-meaningless-program">DEMO - Simple Meaningless Program</a></h1>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/ypJFmc6LgI4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="program-1"><a class="header" href="#program-1">Program</a></h2>
<ul>
<li>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></li>
<li>Registers to Initialize:
<ul>
<li><code>a0 = 0x5</code></li>
</ul>
</li>
<li>Program:</li>
</ul>
<pre><code class="language-assembly">sw a0 0xbc(x0)   # M[0xbc]=a0
li a1 0x7        # -&gt; a1 = 7
li a2 0x3        # -&gt; a2 = 3
lw a3 0xbc(x0)   # a3=M[0xbc]
LOOP:
    add a4 a0 a1     # -&gt; a4=a0+a1
    sub a5 a1 a2     # -&gt; a5=a1-a2
    add a4 a3 a3     # -&gt; a4=a3+a3
    slli a3 a3 1     # -&gt; a3=a3&lt;&lt;1
    bne a5 x0 LOOP    # Branch if a5 is different from zero
</code></pre>
<h2 id="transcript-8"><a class="header" href="#transcript-8">Transcript</a></h2>
<p>The first program actually does nothing meaningful, which helps us focus on how it flows through the processor. We will comment on each cycle of the execution. I suggest pausing the video whenever you feel like you are ready to analyse the next step yourself, and then let the video continue to verify your work. For the Fetch stage we will focus on the choice of the next PC value, for the Decode stage we will focus on the flags that influence the behaviour of the other stages, for the execution stage we will focus on abstracting the alu function, in relation to the instruction function, while in the last two stages we will focus on the completion of the processing of each instruction.</p>
<p>Side note, it is very important that you know hex values and register ABI names by heart, as they will be used interchangeably for naming registers. For example, often values in the visualisations will be in hex, while the register file on the right will have both decimal and ABI representations, or again the assembly code will use ABI register names. Make sure to know them well, not to get confused.</p>
<p>First of all, load the 5 stage processor without forwarding or hazard detection with the extended layout.</p>
<p>Initialise register a0 to the value 5.</p>
<p>Copy and paste the program below in Ripes' Editor tab.</p>
<p>Let us first understand what the program does, even if meaningless. The first instruction loads the value of a0 into the memory cell with address &quot;bc&quot;. The second and the third instructions load 7 and 3 in a1 and a2 respectively. The fourth loads the content of the memory cell &quot;bc&quot; into a3. At this point we will expect a3 to hold the same value as a0.
The next four instructions are simple arithmetic operations. At the end of each we should see respectively a4 equal to 12, a5 equal to 4, a4 equal to 10, a3 equal to 10, because shifting left by 1 position is equivalent to multiplying by 2. The last instruction branches back to the label if a5 is different from zero. Since neither a1 or a2 are being written and a5 will remain their sum, we expect the branch to continue to be taken forever, while both a3 and a4 continue to be doubled forever at each loop.</p>
<p>Let us now comment the execution, cycle by cycle.</p>
<p>Let us now comment the execution, cycle by cycle.</p>
<p>Cycle Zero.</p>
<p>The first instruction is in the Fetch Stage. We can see that the instruction in hexadecimal coming out of the instruction memory, matches the one of the first instruction. This can be done with all following instructions. As we can see from this mux, the next program counter value will be the current one plus four, which means that the instruction immediately following the store will be loaded, in this case the load immediate, or addi. This will not always be the case, we will see what happens when the branch reaches the ex stage, which is where this mux that chooses the next program counter is controlled from.</p>
<p>Cycle One.</p>
<p>For the Fetch stage the same considerations apply as before.
At the same time the Decode stage now contains the store instruction. I remind you that not all the signals in this stage are used by each instruction. For example the store instruction does not have a destination register field, as it uses that same bit range to encode part of the immediate, but we can see some value here nonetheless. The processor ignores the values that have nothing to do with the current instruction, by just not using them. Therefore, we will ignore them too, but you have to know the Instruction Set, to know what to ignore and what to check. For the store instruction, we can verify that the source register 1, which is x0, and the source register 2, which is x10, are indeed retrieved from the register file. At the beginning of the program we expect x10 to contain the value 5, and we can verify it here. Also the immediate output corresponds to the expected value of 188. We can also verify that the register file write enable is not activated, as the store instruction does not have to write to the register file, later in the write back stage. On the other hand, the data memory write enable is active, as the store instruction will write to data memory in the memory stage. The other lit signal is the second operator selector for the alu, which will be used in the next cycle to select the immediate. Finally, one of the signals that is always a good measure to check is the alu control, which now has the value &quot;add&quot;. The store instruction uses the addition function of the alu, because it calculates the address for writing the data memory, by adding an offset, in this case 188, to the value of a register, in this case x0.</p>
<p>Cycle Two.</p>
<p>The execution stage now contains the store instruction and, as expected, the alu is summing the immediate 188 with the content of x0, which is always zero, resulting in 188. This value will be used to address the data memory during the next cycle.</p>
<p>The decode stage contains the load immediate instruction: as before we have to check only the relevant signals. In this case the register file write enable, as this instruction will write 7 in register x11 in the write back stage. The immediate 7, and the flag that allows the alu to use it, as well as the alu control flag, which is once again set on &quot;add&quot;. Finally, the write back select signal is set on alu result. That is because in the write back stage the value that has to be written, in this case to x11, is the result of the sum of 0 and the immediate 7.</p>
<p>As an example of why we ought to ignore the non relevant signals, the register 2 index signal contains the value 7. This has nothing to do with the immediate, just with its encoding. That very same subset of bits, that in other instructions decodes to the source register 2 index field, is used by the addi instruction to encode the immediate 7.</p>
<p>Cycle Three.</p>
<p>The store instruction is now in the Memory stage, and it will be here that it will complete its execution. It will do nothing in the next stage, unlike most other instructions. Here we can see the memory write enable being used, after being calculated in the decode stage two cycles ago. From the decode stage also comes the data in, which is just the content of register 2 and we can confirm it is the value 5, while as already said the address comes from the execution stage, as it is just the alu result.</p>
<p>However, if we look in the memory tab for the memory cell 0xbc, we see that it does not contain the value 5 just yet. This is because, as for any register and therefore any memory, it will show its output at the next cycle.</p>
<p>We can verify in the execution stage that the alu is indeed summing the immediate, with the value zero.</p>
<p>We are not going to repeat anything about the fetch stage, as it contains the very same type of instruction as last cycle. You can use it as exercise also for the next three cycles.</p>
<p>Cycle Four.</p>
<p>Here in the write back stage the instruction does nothing, but we can now verify in the Memory tab that it has actually written the value 5 into memory cell 0xbc.</p>
<p>The instruction in the memory stage also does nothing, as the addi instruction has nothing to do with the data memory.</p>
<p>We are not going to repeat anything about the execution stage, as it contains the very same type of instruction as last cycle. You can use it as exercise.</p>
<p>Finally, the decode stage contains the load: we can see that it will write to the register file in a few cycles, that it uses the immediate 0xbc in the next stage and that it reads from data memory.</p>
<p>Cycle Five.</p>
<p>Here in the write back stage the add immediate instruction finally completes its processing, by selecting the alu result, that two cycles ago was calculated as the sum of 0 and 7, and writing it to the register file at index 0xb.
Mind that at the same time another instruction is in the decode stage, and is doing some other thing in parallel. Since it is an add instruction it is reading two registers from the register file. This instruction is the first of a streak of 4 arithmetic operations, two examples of which you have already seen, so we will focus less on the details from now on.</p>
<p>Analysing the assembly, we found that we expect this add instruction to retrieve the register a0 with value 5, and the register a1 with value 7. However, on the right we can see that the register a1 is still zero, since the value is being written in this cycle and will be visible from the next. Fortunately, the implementation of the register file of this specific processor, allows for reading a register at the same time of it being written, so with input 0xb, which corresponds to a1, we can still see the value 7. But what if this was not the case or worse, what if the previous instruction, the load, needed the value of a1? The value was not ready at the previous cycle. We will cover this case in the next part of the lesson, so remember it.</p>
<p>So the add instruction retrieves the correct values of 5 and 7, and will write their sum in register 14 in the write back stage.</p>
<p>Cycle Six.</p>
<p>The next sub instruction needs the values of registers a1 and a2 being 7 and 3 respectively. Again while a1 is ready from the previous cycle, a2 is being written to the register file right now, as you can see, but thanks to the implementation of this specific register file, it can still be used by the sub instruction.</p>
<p>Cycle Seven.</p>
<p>The same happens now, when the load instruction is writing 5 to the register a3 from the write back stage,and the instruction in the decode stage needs to use it.</p>
<p>Cycle Eight.</p>
<p>None of the add and sub instructions do anything in the memory stage, and they complete their execution in the write back stage. Now, the first instruction of the streak is here in the write back, and all the others will complete here in the next cycles in the same way.</p>
<p>Cycle Nine.</p>
<p>Now the branch instruction is in the decode stage and needs the value of a5, which again is being written at the same time with the value 4. Being the last instruction of the program, the fetch stage remains empty. For confirmation we can see the program counter value in the fetch stage being 24, that is the address of the instruction just after the branch, which is empty. If you manage to sneak a malicious instruction there, congratulations, you have created a very rudimentary virus.</p>
<p>Anyway let us focus on the decoding of the branch instruction. The three lit flags are the do branch flag, the flag that switches the first alu input to the program counter, and the flag that switches the second alu input to the immediate. The alu operation is again &quot;Add&quot;, as the branch instruction in the next cycle will sum the program counter and the negative immediate, to obtain the address of the instruction to jump backwards to.</p>
<p>Remember that the difference between jump and branch is that the jump requires no condition, while the branch does.</p>
<p>Cycle Ten.</p>
<p>The first two stages are empty. The next instruction to fetch is being calculated in this cycle in the execution stage, and depends on whether the branch is taken. You can see the 'branch taken' flag being activated, and ultimately selecting the result of the alu as next program counter, back in the fetch stage. The new value of the program counter is the branch instruction address minus 16, which is the distance in bytes between the branch instruction and the targeted label. Note that the address on any instruction is the same value of the program counter, taken from when the instruction was in the decode stage: they are the same thing. The branch instruction will do nothing in the next two stages. At the next cycle the instruction whose address is the new program counter value will be retrieved. In this case, it is the first instruction of the loop.</p>
<p>From now on the execution will continue in the same way indefinitely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo---program-towards-hazards"><a class="header" href="#demo---program-towards-hazards">DEMO - Program Towards Hazards</a></h1>
<iframe width="100%" height="500" src="https://www.youtube.com/embed/c4yxrV0DsWw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="program-2"><a class="header" href="#program-2">Program</a></h2>
<ul>
<li>
<p>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></p>
</li>
<li>
<p>Registers to Initialize:</p>
<ul>
<li><code>t1 = 0x123</code></li>
<li><code>t2 = 0xbc</code></li>
<li><code>a0 = 0x00000fff</code></li>
</ul>
</li>
<li>
<p>Program:</p>
</li>
</ul>
<pre><code class="language-assembly">sw t1 0(t2)         # M[0xbc] = 0x123
LOOP:
   lw a1 0(t2)      # a1 = M[0xbc] 
   add a2 a1 a1     # a2 = a1+a1
   sw a2 0(t2)      # M[0xbc] = a2
   blt a2 a0 LOOP   # jump if a2&lt;a0
</code></pre>
<h2 id="transcript-9"><a class="header" href="#transcript-9">Transcript</a></h2>
<p>Now onto the next demo.</p>
<p>Load the 5 stage processor without forwarding or hazard detection with the extended layout. This is the same processor as the last demo.</p>
<p>Initialise register t1 to the value 0 ex 123, t2 to the value 0xbc, a0 to the value 0x00000fff.</p>
<p>Copy and paste the program below in Ripes' Editor tab.</p>
<p>Let us first understand what the program does. The first instruction loads the value of t1 into the memory cell with address &quot;bc&quot;, which unlike the last program is addressed with a register instead of with an offset. The second instruction loads such value into the register a1. The next instruction sets a2 to two times a1, and then the program stores this value in the same memory cell 'bc'. Then the program jumps to the start of the loop if a2 is less than a0. Basically, the program doubles the value inside a2 at each loop execution, until it becomes greater than a0. By changing the initialization of a0 we can control how long the program will run (bigger a0 means it runs for more cycles).</p>
<p>Onto the program, let us focus mainly on the decode stage.</p>
<p>Cycle zero to cycle two.</p>
<p>In the decode stage, both the first and second instructions need registers which were initialised, x6 and x7, or t1 and t2. We can verify their values. Let us also keep in mind that the load instruction will write register x11 in the write back stage, which means in cycle five.</p>
<p>Cycle three.</p>
<p>From the analysis of the assembly code, we saw that the add instruction, which is now in the decode stage, uses the value of a1, or x11, that is supposed to be set by the load instruction as 0 ex 123. However, we can see that the value being retrieved for the address 0x0b, which is x11, is zero. That is because, as we were saying for the previous cycle, the load instruction will write the a1 register in cycle five, that is in two cycles. By then the add instruction will be in the memory stage, and cannot use the alu anymore to calculate its sum. </p>
<p>Imagine being the engineers that invented the pipeline. You just subdivided the processor execution into 5 stages, each that executes faster than the full processor. This lets you process more instructions in the same amount of time, because the execution of each happens in parallel to that of four other instructions, at any given time. This also means that each instruction begins its execution, when two or three other instructions are still not completely executed, which is the same as to say that any register that is modified by a given instruction, is not actually modified until at least three cycles after the instruction starts execution. So what if, as in this case with the register a1, the instruction that immediately follows the load needs the loaded value? More in general, given any instruction that modifies the value of a register, what if an instruction immediately after needs to use the new value of that register?
If the problem propagates, it means that execution will contain errors and it cannot be continued. </p>
<p>In cycle four we see that the result of the alu is zero and not the expected 0 ex 246, because the values of the registers were retrieved as zero instead of the expected 0 ex 123. This means that the value that will be written to the a2 register will be zero, which is wrong.</p>
<p>Therefore no, the execution cannot be continued as the current implementation of the pipeline leads to errors.</p>
<p>How to solve problems like this will be the topic of the next lesson, and as assignment you will be asked to analyse another assembly program, which contains a slightly different type of error, and write a small report detailing how you found it, much in the same way in which we have commented on the last two programs.</p>
<p>So, you will also be asked to speculate a solution, based on the following part of the lesson (and, if you want some spoilers, by trying to understand how the other three pipelined processors available in Ripes, solve the problem. Mind that this is not strictly necessary, as those processors will be the main topic of the next lesson) .</p>
<p>Back to our problem, hopefully you have now understood the need for some tweaks to the current pipeline hardware. Let us then try to understand intuitively how this can be solved, which again will be the topic of the next lesson. </p>
<p>In this particular case, the load instruction is writing back to the register file the value 0 ex 123 in cycle five, while the following instruction, the add, retrieves it in cycle three. This kind of occurrence is called a hazard (or more precisely a dependence, which is a possible hazard). There are two ways to make sure that the add can retrieve the correct value. </p>
<p>The first way is to make sure that the add instruction is in the decode stage at cycle five. This implies stalling it there for two cycles, by disabling the IDEX interstage register, while the load continues executing. This also implies that all instructions after the add instruction will be stalled, as if in a cue. Naturally, there would be the need of a chip that detects such occurrences, called a Hazard Detection Unit.</p>
<p>Another way is to pinpoint where exactly the value that the add instruction needs is ready, or where it is really needed. In our case, the value is ready as soon as it is retrieved for memory, in the memory stage, which is one cycle before the original case. At the same time, the value is retrieved in the decode stage but it is not needed there, it is only needed for the alu in the execution stage, that is one cycle after the original case. It is possible to forward the needed value from a point of the pipeline to another, in order to minimise the stall cycles of an instruction that is waiting for a value to be ready. This means in our case, forwarding the value 0 ex 123 for example from the write back stage directly to the execution stage, so that the add instruction must only wait for one cycles instead of two. Again, there would be the need of a chip that handles such occurrences, called a Forwarding Unit.</p>
<p>In the next lesson we will see exactly how to generalise this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignments"><a class="header" href="#assignments">Assignments</a></h1>
<ol>
<li>Simulate the program below in a similar way to the previous lesson. Write a small report (~1 page) in which you describe what execution error you found and how you recognized it, together with what the consequence on the execution of the whole program is. Comment what the assembly does before simulating it and specify any signal that you reckon holds the wrong value and specify why it should hold the value you think is correct. Try to describe what is similar and what differs with the execution error found in the program of the previous lesson. Finally, describe how this error could be solved by using stalls or forwarding values between stages. Do not be afraid to speculate or get this last point wrong, the topic of the next lesson will be exactly this.</li>
</ol>
<ul>
<li>
<p>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></p>
</li>
<li>
<p>Registers to Initialize:</p>
<ul>
<li><code>t1 = 0x123</code></li>
<li><code>a0 = 0x00000fff</code></li>
</ul>
</li>
<li>
<p>Program:</p>
</li>
</ul>
<pre><code class="language-assembly">LOOP:
    add t1 t1 t1 # a2 = t1+t1
    bgt t1 a0 20 #jumpif t1&gt;a0
    add a1 t1 t1 # a1 = t1+t1
    sub a2 t1 t1 # a2 = t1-t1
    j LOOP
</code></pre>
<p><strong>Remember to compile the Post-Test form!</strong></p>
<!-- 2. A COPPIE: la prima persona sceglie uno stage qualunque e un programma tra gli esempi sotto, e "gioca" nel ruolo di tale stage, mente la seconda nel ruolo dello stage successivo. Seguendo come reference la tabella della sezione [4.3](./3.3_soluzioni.md) la prima persona calcola e comunica alla seconda i dati relativi al proprio stage (ultima colonna della tabella), la seconda deve dedurre che istruzione sta nello stage precedente e calcolare di conseguenza i dati relativi al proprio stage nel prossimo ciclo. Ci si corregge con il simulatore, idealmente operato dalla prima persona. Dopo qualche istruzione ci si inverte. Questo esercizio è utile in quanto simile a uno degli esercizi d'esame.
- ESEMPIO:
    - PERSONA 1 sceglie il primo programma tra quelli sotto e lo stage MEM. I dati che passa al collega sono:
        - PC+4 -> 0xc
        - ALUres-> 0x20
        - Data Out -> 0x0
        - RF Write Index -> 0x0
        - RF Write Enable -> 0x0
        - Write Data Select -> 0x1
    - PERSONA 2 riconosce che la prima istruzione nello stage MEM è lo store e calcola i propri dati al prossimo ciclo.
        - RF Write Index -> 0x0
        - RF Write Data -> 0x20
        - RF Write Enable -> 0x0


## Esempi di programmi dall'internet

```assembly
addi x2, x0, 1

loop:
  sub x1, x1, x2
  sw  x1, 4(x0)
  blt x0, x1, loop
```

```assembly
 addi x5,x0,0x11        # set x5 to 0x11
  sw x5, 0x100(x0)       # store at address 0x100
  lw x6, 0x100(x0)       # get from mem
  addi x6,x6,1          
  sw x6, 0x104(x0)       # store to mem 0x104
```

```assembly
   addi x3,x0,0    # i = 0
   addi x4,x0,10   # const 10
loop:
   bge  x3,x4, exit
   addi x3,x3,1
   j loop
exit:
```

```assembly
  addi x3,x0,0       #  s = 0
  addi x4,x0,0       #  i = 0
  addi x5,x0,5       #  const 5
  addi x6,x0,0x100   #  base address of ax[]
  addi x8,x0,0       #  offset = 0
loop:
  bge x4, x5, exit
  add x7, x6, x8    # compute effective address
  lw  x9, 0(x7)     # get ax[i]
  add x3, x3, x9    # s = s + ax[i]
  addi x8, x8, 4    # next element
  addi x4, x4, 1    # increment index
  j loop
exit:
``` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>Embedded below is the pdf summorizing the entire RISC-V instruction set (RV32IMAC), which is useful during most lessons. The pdf is structured as follows:</p>
<ul>
<li><code>p.1</code> - Instructions on how to read the tables.</li>
<li><code>p.2</code> - Registers Table.</li>
<li><code>p.3-5</code> - Encoder Table (to translate assembly into binary machine code manually).</li>
<li><code>p.6-7 </code> - Decoder Table (to translate binary machine code into assembly manually)</li>
</ul>
<p><a href="https://nbviewer.org/github/magiwanders/pipeline_lesson/blob/main/RV32IMAC_Sliderule_Encoder_Decoder_v0.1.6.pdf" target="_blank">Open PDF in another tab</a></p>
<iframe src="https://nbviewer.org/github/magiwanders/pipeline_lesson/blob/main/RV32IMAC_Sliderule_Encoder_Decoder_v0.1.6.pdf" width="100%" height="720" allow="autoplay"></iframe>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="submodules/js_builds_html/html_builders.js"></script>
        <script type="text/javascript" src="submodules/paint2pic/p2p.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/digitaljs_webpack_backup.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/lz-string_backup.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/sheas_functions.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/sheas_builders.js"></script>
        <script type="text/javascript" src="lesson.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
