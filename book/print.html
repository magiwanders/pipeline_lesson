<!DOCTYPE HTML>
<html lang="it" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduzione al Pipelining</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="scrollbar.css">
        <link rel="stylesheet" href="loader.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0_overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="0.1_setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="0.2_important_info.html"><strong aria-hidden="true">1.2.</strong> Important Info</a></li><li class="chapter-item expanded "><a href="0.3_pretest.html"><strong aria-hidden="true">1.3.</strong> Pre-test</a></li></ol></li><li class="chapter-item expanded "><a href="1_prerequisiti.html"><strong aria-hidden="true">2.</strong> Prerequisiti</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1_esercizi.html"><strong aria-hidden="true">2.1.</strong> Esercizi</a></li><li class="chapter-item expanded "><a href="1.2_soluzioni.html"><strong aria-hidden="true">2.2.</strong> Soluzioni</a></li><li class="chapter-item expanded "><a href="1.3_altri_prerequisiti.html"><strong aria-hidden="true">2.3.</strong> Altri Prerequisiti</a></li><li class="chapter-item expanded "><a href="1.4_registro.html"><strong aria-hidden="true">2.4.</strong> Registro</a></li><li class="chapter-item expanded "><a href="1.5_rom.html"><strong aria-hidden="true">2.5.</strong> ROM</a></li><li class="chapter-item expanded "><a href="1.6_register_file.html"><strong aria-hidden="true">2.6.</strong> Register File</a></li><li class="chapter-item expanded "><a href="1.7_pc.html"><strong aria-hidden="true">2.7.</strong> PC</a></li><li class="chapter-item expanded "><a href="1.8_alu.html"><strong aria-hidden="true">2.8.</strong> ALU</a></li></ol></li><li class="chapter-item expanded "><a href="2_temporizzazione.html"><strong aria-hidden="true">3.</strong> Temporizzazione (Tutorial SHEAS)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1_ritardo_di_propagazione.html"><strong aria-hidden="true">3.1.</strong> Ritardo di Propagazione</a></li><li class="chapter-item expanded "><a href="2.2_rtl.html"><strong aria-hidden="true">3.2.</strong> RTL</a></li><li class="chapter-item expanded "><a href="2.3_esercizi.html"><strong aria-hidden="true">3.3.</strong> Esercizi</a></li><li class="chapter-item expanded "><a href="2.4_soluzioni.html"><strong aria-hidden="true">3.4.</strong> Soluzioni</a></li><li class="chapter-item expanded "><a href="2.5_diagramma_rtl.html"><strong aria-hidden="true">3.5.</strong> Diagramma RTL</a></li><li class="chapter-item expanded "><a href="2.6_pipeline.html"><strong aria-hidden="true">3.6.</strong> Pipeline</a></li><li class="chapter-item expanded "><a href="2.7_esercizi.html"><strong aria-hidden="true">3.7.</strong> Esercizi</a></li><li class="chapter-item expanded "><a href="2.8_soluzioni.html"><strong aria-hidden="true">3.8.</strong> Soluzioni</a></li></ol></li><li class="chapter-item expanded "><a href="3_costruzione_pipeline.html"><strong aria-hidden="true">4.</strong> Pipeline Building (Tutorial Ripes)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1_from_singlecycle.html"><strong aria-hidden="true">4.1.</strong> From Single-Cycle</a></li><li class="chapter-item expanded "><a href="3.2_exercises.html"><strong aria-hidden="true">4.2.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="3.3_soluzioni.html"><strong aria-hidden="true">4.3.</strong> Soluzioni</a></li><li class="chapter-item expanded "><a href="3.4_stages.html"><strong aria-hidden="true">4.4.</strong> Stages</a></li></ol></li><li class="chapter-item expanded "><a href="4_demos.html"><strong aria-hidden="true">5.</strong> Demos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1_simple_meaningless_program.html"><strong aria-hidden="true">5.1.</strong> Simple Meaningless Program</a></li><li class="chapter-item expanded "><a href="4.2_towards_hazards.html"><strong aria-hidden="true">5.2.</strong> Towards Hazards</a></li><li class="chapter-item expanded "><a href="4.3_assignments.html"><strong aria-hidden="true">5.3.</strong> Assignments</a></li></ol></li><li class="chapter-item expanded "><a href="5_appendix.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1_posttest.html"><strong aria-hidden="true">6.1.</strong> Post-test</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduzione al Pipelining</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Questa lezione si può navigare dal menu sulla sinistra (prima icona in alto a sinistra) o anche solo con <code>Arrow Key Right</code> e <code>Arrow Key Left</code> (le freccette destra e sinistra della tastiera). </p>
<p>This site uses no server cookies. Local storage is used, but only not to lose the user input to the site's widgets at every refresh.</p>
<p>Per continuare, click <code>Arrow Key Right</code> o seleziona uno dei link sotto.</p>
<ul>
<li><a href="./0_overview.html">Overview</a>
<ul>
<li><a href="./0.1_setup.html">Setup</a></li>
<li><a href="./0.2_informazioni_importanti.html">Informazioni Importanti</a></li>
</ul>
</li>
<li><a href="./1_prerequisiti.html">Prerequisiti</a>
<ul>
<li><a href="./1.1_esercizi.html">Esercizi</a></li>
<li><a href="./1.2_soluzioni.html">Soluzioni</a></li>
<li><a href="./1.3_altri_prerequisiti.html">Altri Prerequisiti</a></li>
<li><a href="./1.4_registro.html">Registro</a></li>
<li><a href="./1.5_rom.html">ROM</a></li>
<li><a href="./1.6_register_file.html">Register File</a></li>
<li><a href="./1.7_pc.html">PC</a></li>
<li><a href="./1.8_alu.html">ALU</a></li>
</ul>
</li>
<li><a href="./2_temporizzazione.html">Temporizzazione (Tutorial SHEAS)</a>
<ul>
<li><a href="./2.1_ritardo_di_propagazione.html">Ritardo di Propagazione</a></li>
<li><a href="./2.2_rtl.html">RTL</a></li>
<li><a href="./2.3_esercizi.html">Esercizi</a></li>
<li><a href="./2.4_soluzioni.html">Soluzioni</a></li>
<li><a href="./2.5_diagramma_rtl.html">Diagramma RTL</a></li>
<li><a href="./2.6_pipeline.html">Pipeline</a></li>
<li><a href="./2.7_esercizi.html">Esercizi</a></li>
<li><a href="./2.8_soluzioni.html">Soluzioni</a></li>
</ul>
</li>
<li><a href="./3_costruzione_pipeline.html">Costruzione Pipeline (Tutorial Ripes)</a>
<ul>
<li><a href="./3.1_from_singlecycle.html">Dal Single-Cycle</a></li>
<li><a href="./3.2_exercises.html">Esercizi</a></li>
<li><a href="./3.3_soluzioni.html">Soluzioni</a></li>
<li><a href="./3.4_stages.html">Stages</a></li>
</ul>
</li>
<li><a href="./4_demos.html">Demos</a>
<ul>
<li><a href="./4.1_simple_meaningless_program.html">Simple Meaningless Program</a></li>
<li><a href="./4.2_towards_hazards.html">Towards Hazards</a></li>
<li><a href="./4.3_assignments.html">Assignments</a></li>
</ul>
</li>
<li><a href="./5_appendix.html">Appendice</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<ul>
<li>Scaricare la Virtual Machine per la lezione <a href="https://drive.google.com/uc?export=download&amp;id=1MIDXYVtsaYKxCYUdW-lFQ8cbkSl-Truh">QUI</a> (il file <code>comparch.ova</code> è relativamente grande, ~2.7GB)</li>
<li>Scaricare e installare <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank">VirtualBox</a> per il proprio sistema.</li>
<li>Aprire VirtualBox e importare il file <code>comparch.ova</code>:
<ul>
<li><code>File &gt; Import Appliance</code></li>
<li>Selezionare il file <code>comparch.ova</code></li>
<li>Click <code>Next</code>, click <code>Import</code></li>
<li>Una nuova Virtual Machine dovrebbe comparire nella finestra principale. Doppio click per avviarla.</li>
</ul>
</li>
</ul>
<h2 id="software"><a class="header" href="#software">Software</a></h2>
<p>Durante questa lezione verranno usati due tool:</p>
<ul>
<li><code>S.H.E.A.S. (Simple Hardware Editor and Simulator)</code> - Un simulatore di porte logiche disponibile anche <a href="https://sheas.magiwanders.com">online</a> ma che nella gran parte dei casi sarà embedded nelle pagine di questo sito.</li>
<li><code>Ripes</code> - un simulatore di processori RISC-V.</li>
</ul>
<p>Più avanti nella lezione saranno disponibili dei tutorial di entrambi questi tool, in particolare:</p>
<ul>
<li>Tutorial di <code>S.H.E.A.S.</code> nella sezione <a href="./2_temporizzazione.html">Temporizzazione</a></li>
<li>Tutorial di <code>Ripes</code> nella sezione <a href="./3_costruzione_pipeline.html">Costruzione Pipeline</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="informazioni-importanti-sulla-macchina-virtuale"><a class="header" href="#informazioni-importanti-sulla-macchina-virtuale">Informazioni importanti sulla macchina virtuale</a></h2>
<p>Seguono una serie di informazioni non strettamente necessarie per la lezione, ma che potrebbero essere utili per utilizzare la virtual machine:</p>
<p><strong>Alcune finestre di Ripes, come quella del Pipeline Diagram, NON hanno il bottone 'x' per chiuderle. Usare 'Esc' sulla tastiera.</strong></p>
<ul>
<li>La virtual machine contiene solo il programma <code>Ripes</code>, il quale si apre allo startup. Servirà dalla seconda parte della lezione.</li>
<li>Verificare che il copia-incolla funzioni tra l'host e il guest (banalmente per copiare e incollare i programmi assembly dentro <code>Ripes</code>).</li>
<li>Credenziali: 
<ul>
<li>user: <code>student</code></li>
<li>psw : <code>student</code></li>
</ul>
</li>
<li>Sistema: <code>Manjaro i3 minimal aggiornato a settembre 2022</code>. Non si consiglia di aggiornarlo/modificarlo.</li>
<li>Come aprire un terminale:
<ul>
<li><code>Alt+2</code> </li>
<li><code>Alt+Enter</code></li>
<li>Il terminale è un terminale standard linux. Se si desidera modificare la configurazione di i3, modificare il file <code>~/.config/i3/config</code> con <code>nano</code>:
<ul>
<li><code>sudo nano ~/.config/i3/config</code></li>
</ul>
</li>
</ul>
</li>
<li>Per ritornare a Ripes in qualunque momento:
<ul>
<li><code>Alt+1</code></li>
</ul>
</li>
<li>Se per qualunque motivo Ripes si chiude, riavviare la macchina virtuale.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pretest"><a class="header" href="#pretest">Pretest</a></h1>
<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSerBSW7TVmaMTdVEQ43aB16SO2swQibapUNqwNOuBqMT74s0A/viewform?embedded=true" width="100%" height="1000" frameborder="0" marginheight="0" marginwidth="0">Loading…</iframe><div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisiti"><a class="header" href="#prerequisiti">Prerequisiti</a></h1>
<p>Per seguire con successo la lezione bisogna avere conoscenze adeguate su:</p>
<ul>
<li>Calcoli in esadecimale e in complemento a 2.</li>
<li>Instruction set RV32I </li>
<li>Funzionamento di un processore a singolo ciclo e dei suoi componenti:
<ul>
<li>Registri</li>
<li>Memorie</li>
<li>Register File (RF)</li>
<li>PC</li>
<li>ALU</li>
</ul>
</li>
</ul>
<h3 id="indice"><a class="header" href="#indice">Indice</a></h3>
<ul>
<li><a href="./1.1_esercizi.html">Esercizi</a></li>
<li><a href="./1.2_soluzioni.html">Soluzioni</a></li>
<li><a href="./1.3_altri_prerequisiti.html">Altri Prerequisiti</a></li>
<li><a href="./1.4_registro.html">Registro</a></li>
<li><a href="./1.5_rom.html">ROM</a></li>
<li><a href="./1.6_register_file.html">Register File</a></li>
<li><a href="./1.7_pc.html">PC</a></li>
<li><a href="./1.8_alu.html">ALU</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esercizi-sui-prerequisiti"><a class="header" href="#esercizi-sui-prerequisiti">Esercizi sui Prerequisiti</a></h1>
<p>Si ricorda che nella sezione <a href="./5_appendix.html">Appendice</a> è presente un PDF riassuntivo dell'intero Instruction Set RV32IMAC.</p>
<ol>
<li>
<p>Disassemblare le seguenti istruzioni:</p>
<ol>
<li><code>0x01e007ef</code></li>
<li><code>0x0001e7b7</code></li>
<li><code>0x00440113</code></li>
<li><code>0x40445113</code></li>
<li><code>0x403100b3</code></li>
<li><code>0xfea64ae3</code></li>
<li><code>0x0003a583</code></li>
<li><code>0x00b3a023</code></li>
</ol>
</li>
<li>
<p>Assemblare le seguenti istruzioni (ESEMPIO):</p>
<ol>
<li><code>j -12</code></li>
<li><code>auipc sp 8</code></li>
<li><code>andi sp, s0, 4</code></li>
<li><code>sltiu sp, s0, 4</code></li>
<li><code>or ra, sp, gp</code></li>
<li>Solo l'istruzione di branch del seguente programma:
<ul>
<li><code>&lt;LABEL&gt;</code></li>
<li>    <code>lw a1 0(t2)</code></li>
<li>    <code>add a2 a1 a1</code></li>
<li>    <code>sw a1 0(t2)</code></li>
<li>    <code>bgtz sp &lt;LABEL&gt;</code></li>
</ul>
</li>
<li><code>lw a7 8(t2)</code></li>
<li><code>sw a7 8(t2)</code></li>
</ol>
</li>
</ol>
<h2 id="esempi-di-svolgimento"><a class="header" href="#esempi-di-svolgimento">Esempi di Svolgimento</a></h2>
<h3 id="disassemblaggio-dellistruzione-0x01e007ef"><a class="header" href="#disassemblaggio-dellistruzione-0x01e007ef">Disassemblaggio dell'istruzione <code>0x01e007ef</code></a></h3>
<p>Per prima cosa si esegue la conversione da esadecimale a binario:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">hex</th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>1</code></th><th style="text-align: center"><code>e</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>7</code></th><th style="text-align: center"><code>e</code></th><th style="text-align: center"><code>f</code></th></tr></thead><tbody>
<tr><td style="text-align: center">bin</td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0001</code></td><td style="text-align: center"><code>1110</code></td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0000</code></td><td style="text-align: center"><code>0111</code></td><td style="text-align: center"><code>1110</code></td><td style="text-align: center"><code>1111</code></td></tr>
</tbody></table>
</div>
<p>Poi si identifica il tipo di istruzione e i suoi campi, generalmente leggendo da destra a sinistra il binario, per più facile consultazione delle tabelle del Decoder nell'<a href="./5_appendix.html">Appendice</a>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">RV32I</th><th style="text-align: center"><code>00000001111000000000</code></th><th style="text-align: center"><code>01111</code></th><th style="text-align: center"><code>11011</code></th><th style="text-align: center"><code>11</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Meaning</td><td style="text-align: center"><code>&lt;imm&gt; (encoded)</code></td><td style="text-align: center"><code>rd</code></td><td style="text-align: center"><code>opcode</code></td><td style="text-align: center"><code>quadrant</code></td></tr>
<tr><td style="text-align: center">Value</td><td style="text-align: center"><code>&lt;imm&gt;</code></td><td style="text-align: center">15</td><td style="text-align: center">Jump and Link</td><td style="text-align: center">4th</td></tr>
</tbody></table>
</div>
<p>Si ottiene quindi l'istruzione <code>jal x15 &lt;imm&gt;</code>, dove <code>&lt;imm&gt;</code> è l'immediate in decimale ancora da calcolare.</p>
<p>Per tutti campi tranne <code>&lt;imm&gt;</code> il decoding del valore è infatti leggibile direttamente dalle tabelle. Per <code>&lt;imm&gt;</code> bisogna effettuare un passaggio in più (sostanzialmente un riordino di bit) prima di poterlo calcolare.</p>
<p>Si identificano i sotto-campi dell'immediate:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>&lt;imm&gt; (encoded)</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>0000001111</code></th><th style="text-align: center"><code>0</code></th><th style="text-align: center"><code>00000000</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Encoding</td><td style="text-align: center"><code>m2</code></td><td style="text-align: center"><code>imm2</code></td><td style="text-align: center"><code>m1</code></td><td style="text-align: center"><code>imm1</code></td></tr>
</tbody></table>
</div>
<p>Si riordinano i sottocampi come indicato nelle tabelle del Decoder nell'<a href="./5_appendix.html">Appendice</a>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Decoding di <code>&lt;imm&gt;</code></th><th style="text-align: center"><code>-m2-</code></th><th style="text-align: center"><code>imm1</code></th><th style="text-align: center"><code>m1</code></th><th style="text-align: center"><code>imm2</code></th><th style="text-align: center"><code>0</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&lt;imm&gt; (bin)</code></td><td style="text-align: center"><code>000000000000</code></td><td style="text-align: center"><code>00000000</code></td><td style="text-align: center"><code>0</code></td><td style="text-align: center"><code>0000001111</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
</div>
<p>Si ottiene il numero in complemento a 2 </p>
<ul>
<li><code>&lt;imm&gt; (bin)</code> = <code>00000000000000000000000000011110</code> in binario</li>
</ul>
<p>ossia </p>
<ul>
<li><code>&lt;imm&gt; (dec)</code> = <code>30</code> in decimale.</li>
</ul>
<p>L'istruzione disassemblata completa corrispondente a <code>0x01e007ef</code> è quindi <code>jal x15 30</code>, o <code>jal a5 30</code> usando i nomi ABI dei registri.</p>
<h3 id="assemblaggio-dellistruzione-j--12"><a class="header" href="#assemblaggio-dellistruzione-j--12">Assemblaggio dell'istruzione <code>j -12</code></a></h3>
<p>Si controlla sulle tabelle dell'Encoder nell'<a href="./5_appendix.html">Appendice</a> l'encoding dei campi dell'istruzione <code>j</code>. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Encoding dell'istruzione <code>j</code></th><th style="text-align: center"><code>&lt;imm&gt; (encoded)</code></th><th style="text-align: center">00000</th><th style="text-align: center">11011</th><th style="text-align: center">11</th></tr></thead><tbody>
</tbody></table>
</div>
<p>I bit meno significativi dell'istruzione in binario saranno quindi <code>xxxxxxxxxxxxxxxxxxxx000001101111</code>. Rimane solo da convertire <code>&lt;imm&gt; = 30 </code> in <code>&lt;imm&gt; (encoded)</code>.</p>
<p>Per prima cosa si converte in complemento a due il decimale <code>&lt;imm&gt;</code> = <code>-12</code>, che diventa <code>&lt;imm&gt; (bin)</code> = <code>10100</code>, <code>&lt;imm&gt; (bin)</code> = <code>11111111111111111111111111110100</code> se esteso di segno per riempire tutti i <code>32 bit</code>dell'Instruction Set.</p>
<p>Si divide questo numero nei dovuti sottocampi, come da Encoder nell'<a href="./5_appendix.html">Appendice</a>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>&lt;imm&gt; (bin)</code></th><th style="text-align: center"><code>111111111111</code></th><th style="text-align: center"><code>11111111</code></th><th style="text-align: center"><code>1</code></th><th style="text-align: center"><code>1111111010</code></th><th style="text-align: center"><code>0</code></th></tr></thead><tbody>
<tr><td style="text-align: center">Decoding di <code>&lt;imm&gt;</code></td><td style="text-align: center"><code>-m2-</code></td><td style="text-align: center"><code>imm1</code></td><td style="text-align: center"><code>m1</code></td><td style="text-align: center"><code>imm2</code></td><td style="text-align: center"><code>0</code></td></tr>
</tbody></table>
</div>
<p>Si riordinano i sottcampi per ottenere l'immediate codificato:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Encoding</th><th style="text-align: center"><code>m2</code></th><th style="text-align: center"><code>imm2</code></th><th style="text-align: center"><code>m1</code></th><th style="text-align: center"><code>imm1</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>&lt;imm&gt; (encoded)</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center"><code>1111111010</code></td><td style="text-align: center"><code>1</code></td><td style="text-align: center"><code>11111111</code></td></tr>
</tbody></table>
</div>
<p>Si ottiene <code>&lt;imm&gt; (encoded)</code> = <code>11111111010111111111xxxxxxxxxxxx</code>, ossia i bit più significativi dell'istruzione. </p>
<p>L´istruzione completa in binario corrispondente a <code>j -12</code> è quindi <code>11111111010111111111000001101111</code> per concatenazione dei due risultati sopra.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soluzioni-degli-esercizi-alla-pagina-precedente"><a class="header" href="#soluzioni-degli-esercizi-alla-pagina-precedente">Soluzioni degli esercizi alla pagina precedente</a></h1>
<ol>
<li>
<p>Disassemblare le seguenti istruzioni:</p>
<ol>
<li><code>0x01e007ef</code> -&gt; <code>jal a5 30</code></li>
<li><code>0x0001e7b7</code> -&gt; <code>lui a5 30</code></li>
<li><code>0x00440113</code> -&gt; <code>addi sp, s0, 4</code></li>
<li><code>0x40445113</code> -&gt; <code>srai sp, s0, 4</code></li>
<li><code>0x403100b3</code> -&gt; <code>sub ra, sp, gp</code></li>
<li><code>0xfea64ae3</code> -&gt; <code>blt x12 x10 -12</code></li>
<li><code>0x0003a583</code> -&gt; <code>lw a1 0(t2)</code></li>
<li><code>0x00b3a023</code> -&gt; <code>sw a1 0(t2)</code></li>
</ol>
</li>
<li>
<p>Assemblare le seguenti istruzioni (ESEMPIO):</p>
<ol>
<li><code>j -12</code> -&gt; <code>0xff5ff06f</code></li>
<li><code>auipc sp 8</code> -&gt; <code>0x00008117</code></li>
<li><code>andi sp, s0, 4</code> -&gt; <code>0x00447113</code></li>
<li><code>sltiu sp, s0, 4</code> -&gt; <code>0x00443113</code></li>
<li><code>or ra, sp, gp</code> -&gt; <code>0x003160b3</code></li>
<li>Solo l'istruzione di branch del seguente programma:
<ul>
<li><code>&lt;LABEL&gt;</code></li>
<li>    <code>lw a1 0(t2)</code></li>
<li>    <code>add a2 a1 a1</code></li>
<li>    <code>sw a1 0(t2)</code></li>
<li>    <code>bgtz sp &lt;LABEL&gt;</code> -&gt; <code>0xfe204ae3</code></li>
</ul>
</li>
<li><code>lw a7 8(t2)</code> -&gt; <code>0x0083a883</code></li>
<li><code>sw a7 8(t2)</code> -&gt; <code>0x0113a423</code></li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="altri-prerequisiti"><a class="header" href="#altri-prerequisiti">Altri Prerequisiti</a></h1>
<p>È responsabilità dello studente ripassare il funzionamento del processore a singolo ciclo e dei suoi componenti, in particolare: </p>
<ul>
<li>Registri</li>
<li>Memorie</li>
<li>Register File (RF)</li>
<li>PC</li>
<li>ALU</li>
</ul>
<p>Segue un elenco di circuiti di S.H.E.A.S. (un tool di simulazione il cui funzionamento è spiegato in un video tutorial nella sezione di <a href="./2_temporizzazione.html">Temporizzazione</a>).</p>
<ul>
<li><a href="./1.4_registro.html">Registro a 32 bit</a></li>
<li><a href="./1.5_rom.html">ROM a 8 bit</a></li>
<li><a href="./1.6_register_file.html">Register File (RF) a 32 bit</a></li>
<li><a href="./1.7_pc.html">PC a 8 bit</a></li>
<li><a href="./1.8_alu.html">ALU a 32 bit</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registro"><a class="header" href="#registro">Registro</a></h1>
<p>Circuito interattivo di un registro a 32 bit.</p>
<div id="sheas_container_register"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rom"><a class="header" href="#rom">ROM</a></h1>
<p>Circuito interattivo di una memoria non scrivibile (ROM - Read Only Memory), buon (semplice) modello per esempio per l'Instruction Memory.</p>
<p>La memoria nel circuito contiene il programma:</p>
<ul>
<li><code>&lt;LABEL&gt;</code></li>
<li>    <code>lw a1 0(t2)</code></li>
<li>    <code>add a2 a1 a1</code></li>
<li>    <code>sw a1 0(t2)</code></li>
<li>    <code>bgtz sp &lt;LABEL&gt;</code></li>
</ul>
<div id="sheas_container_rom"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-file"><a class="header" href="#register-file">Register File</a></h1>
<p>Circuito interattivo di un Register File (RF) a 32 bit (design di <a href="https://github.com/tilk">Marek Materzok</a>). Notare che il design è puramente funzionale, non scende nel livello di dettaglio delle porte logiche.</p>
<div id="sheas_container_registerfile"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pc"><a class="header" href="#pc">PC</a></h1>
<p>Circuito interattivo di un Program Counter a 8 bit.</p>
<div id="sheas_container_pc"><div style="width:100%; height:100%"><div class="loader"></div></div></div><div style="break-before: page; page-break-before: always;"></div><h1 id="alu"><a class="header" href="#alu">ALU</a></h1>
<p>Circuito interattivo di una ALU 32 bit (design di <a href="https://github.com/tilk">Marek Materzok</a>). Notare che il design è puramente funzionale, non scende nel livello di dettaglio delle porte logiche.</p>
<div id="sheas_container_alu"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temporizzazione"><a class="header" href="#temporizzazione">Temporizzazione</a></h1>
<iframe width="854" height="480" src="https://www.youtube.com/embed/CUn9LVzQL0g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="indice-1"><a class="header" href="#indice-1">Indice</a></h3>
<ul>
<li><a href="./2.1_ritardo_di_propagazione.html">Ritardo di Propagazione</a></li>
<li><a href="./2.2_rtl.html">RTL</a></li>
<li><a href="./2.3_esercizi.html">Esercizi</a></li>
<li><a href="./2.4_soluzioni.html">Soluzioni</a></li>
<li><a href="./2.5_diagramma_rtl.html">Diagramma RTL</a></li>
<li><a href="./2.6_pipeline.html">Pipeline</a></li>
<li><a href="./2.7_esercizi.html">Esercizi</a></li>
<li><a href="./2.8_soluzioni.html">Soluzioni</a></li>
</ul>
<h2 id="trasncript"><a class="header" href="#trasncript">TRASNCRIPT</a></h2>
<p>This is a basic tutorial for SHEAS one point one, a tool based on the DigitalJS open source logic simulation engine, originally created for visualizing and simulating verilog code by Marek Materzock. </p>
<p>SHEAS stands for Simple Hardware Editor And Simulator, and it provides DigitalJS with a basic interface that allows for completely code-free hardware modification and simulation, and in a near future, testing too. </p>
<p>SHEAS is open source too, and a live running page can be found at sheas.magiwanders.com.</p>
<p>Components are chosen from the dropdown and added to the simulation. The base components are buttons for inputs, lamps for outputs, and nand ports for synthesizing logic. Each of these has a 'bits' attribute which describes the width of their ports. More components are available in the dropdown and new ones are constantly added. </p>
<p>In the Visualization Window, components are moved by drag and drop and connected by dragging and dropping, from the output of one to the input of the other. If any glitch happens, the visualization can at any point be reloaded.</p>
<p>The simulation is already running by default, and at any point, clicking the blue looking glass that appears upon hovering each wire will activate a signal monitor below. To see the details, like the exact delay between signal activations, the simulation can be paused and forwarded step by step, while the signal monitors can be zoomed in and out, and navigated horizontally to the left or to the right. </p>
<p>Any component can be renamed. Any component can also be removed by name.
No two components can have the same name, the page will output an error if trying to rename one to an already existing name.</p>
<p>At any point, the circuit can be saved for later retrieval, and the simulation can be reset.</p>
<p>Saved circuits are retrieved either as they were saved, with the load button, or as black boxes, with the add button. The black box can be used as any other component, and its internal ports can be accessed with the looking glass icon that appears upon hovering it.</p>
<p>At any point the current circuit can be shared by clicking the 'share circuit as link' button and pasting the link into another window. Mind that due to the limitations on the URL length, this only works for all but the biggest circuits. Alternatively, clicking the 'share only the chip' button will copy the chip in the clipboard. In another window, the chip can be retrieved with the dropdown option 'Circuit from Clipboard'.  This works with much bigger circuits.</p>
<p>That is all, thank you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ritardo-di-propagazione"><a class="header" href="#ritardo-di-propagazione">Ritardo di Propagazione</a></h1>
<p>In questa parte della lezione si ricorda che le porte logiche studiate finora &quot;calcolano&quot; il proprio output con un certo ritardo di propagazione, e si studiano le conseguenze che questo ha sulla frequenza di clock di un processore.</p>
<div id="sheas_container_1"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtl"><a class="header" href="#rtl">RTL</a></h1>
<p>In questa parte della lezione si ricorda la logica RTL e come il ritardo di propagazione la limita.</p>
<div id="sheas_container_2"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esercizi"><a class="header" href="#esercizi">Esercizi</a></h1>
<ol>
<li>Qualitativamente, che ritardo di propagazione ci si può aspettare da un chip Full Adder? Nel precedente circuito si trovano dei Full Adder dentro al chip &quot;Incrementer&quot;. Se serve, un Full Adder isolato:</li>
</ol>
<div id="sheas_container_fulladder"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<ol start="2">
<li>Il ritardo di propagazione dell'Incrementer cambia a seconda dell'input? Se si perchè?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soluzioni"><a class="header" href="#soluzioni">Soluzioni</a></h1>
<ol>
<li><code>Qualitativamente, che ritardo di propagazione ci si può aspettare da un chip Full Adder? </code> 1 ciclo per NOT, 2 per AND e OR, 5 per XOR, 5 per HALF ADDER, circa 12 per FULL ADDER.</li>
<li><code>Il ritardo di propagazione dell'Incrementer cambia a seconda dell'input? Se si perchè?</code> No, il ritardo di propagazione del circuito è sempre lo stesso, ma il &quot;risultato corretto&quot; appare con tanto più ritardo quanto più vicino al msb è il bit che cambia più significativo nella data operazione.  L'incrementer infatti processa il msb solo dopo che si è propagata tutta la catena di Full Adder precedenti (i quali sono collegati in serie visto che ognuno ha in input l'output &quot;carry&quot; del precedente) e tanto più i bit che &quot;cambiano&quot; in una data operazione sono vicini al msb, tanto più devono aspettare per essere processati.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diagramma-rtl"><a class="header" href="#diagramma-rtl">Diagramma RTL</a></h1>
<p>In questa parte della lezione si introduce un semplice diagramma per rappresentare l'esecuzione nel tempo di una logica RTL.</p>
<div id="sheas_container_3"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<p>Usare la tabella sotto per disegnare il diagramma:</p>
<table class="table">
  <thead>
    <tr>
        <th>Input</th>
        <th>Cycle 1</th>
        <th>Cycle 2</th>
        <th>Cycle 3</th>
        <th>Cycle 4</th>
        <th>Cycle 5</th>
        <th>Cycle 6</th>
        <th>Cycle 7</th>
        <th>Cycle 8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th><div><input size=2 type="string" id='2.5.1.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.1.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.2.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.3.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.4.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.5.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.6.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.7.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.8.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.5.9.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.5.9.9' onchange="save_table(event)"></div></th>
    </tr>
  </tbody>
</table>
<p>Per capire meglio, ecco la stessa tabella compilata per l'attività giornaliera di una lavanderia 24/7, provvista di una lavatrice (1.45h per lavare), una asciugatrice (1.30 h per asciugare) e una stiratrice (2h per stirare):</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Orario</th><th style="text-align: center">8:00-13:15</th><th style="text-align: center">13:15-18:30</th><th style="text-align: center">18:30-23.45</th><th style="text-align: center">23:45-5:00</th><th style="text-align: center">5:00-10:15</th></tr></thead><tbody>
<tr><td style="text-align: center">Cliente 1</td><td style="text-align: center">Lava+Asciuga+Stira</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 2</td><td style="text-align: center"></td><td style="text-align: center">Lava+Asciuga+Stira</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 3</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava+Asciuga+Stira</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 4</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava+Asciuga+Stira</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 5</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava+Asciuga+Stira</td></tr>
</tbody></table>
</div>
<p>Come ottimizzare il lavoro della lavanderia? La risposta a questa domanda, riportata nel dominio del processore a singolo ciclo, è l'argomento fulcro della lezione.</p>
<details>
  <summary>La soluzione, per la lavanderia</summary>
<p>Come è facile intuire, l'ottimizzazione più semplice è far usare contemporaneamente a tre clienti ognuna delle tre macchine. In questo modo per &quot;cambiare postazione&quot; bisogna aspettare la postazione più lenta, ossia la stiratura, quindi bisogna aspettare 2h. Ogni cliente finisce in più tempo (6 ore contro 5.15), ma la lavanderia processa un cliente ogni 2 ore invece che uno ogni 5 e un quarto.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Orario</th><th style="text-align: center">8:00-10:00</th><th style="text-align: center">10:00-12:00</th><th style="text-align: center">12:00-14:00</th><th style="text-align: center">14:00-16:00</th><th style="text-align: center">16:00-18:00</th><th style="text-align: center">18:00-20:00</th><th style="text-align: center">20:00-22:00</th></tr></thead><tbody>
<tr><td style="text-align: center">Cliente 1</td><td style="text-align: center">Lava (e aspetta 15 min)</td><td style="text-align: center">Asciuga (e aspetta 30 min)</td><td style="text-align: center">Stira</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 2</td><td style="text-align: center"></td><td style="text-align: center">Lava (e aspetta 15 min)</td><td style="text-align: center">Asciuga (e aspetta 30 min)</td><td style="text-align: center">Stira</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 3</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava (e aspetta 15 min)</td><td style="text-align: center">Asciuga (e aspetta 30 min)</td><td style="text-align: center">Stira</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 4</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava (e aspetta 15 min)</td><td style="text-align: center">Asciuga (e aspetta 30 min)</td><td style="text-align: center">Stira</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">Cliente 5</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">Lava (e aspetta 15 min)</td><td style="text-align: center">Asciuga (e aspetta 30 min)</td><td style="text-align: center">Stira</td></tr>
</tbody></table>
</div></details>
<style type="text/css">
   input {font-weight:bold;}
</style>
<script>
    for (var i=1; i<10; i++) {
        for (var j=1; j<10; j++) {
            var id = '2.5.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) { localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script><div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h1>
<div id="sheas_container_4"><div style="width:100%; height:100%"><div class="loader"></div></div></div>
<table class="table">
  <thead>
    <tr>
        <th>Input</th>
        <th>Cycle 1</th>
        <th>Cycle 2</th>
        <th>Cycle 3</th>
        <th>Cycle 4</th>
        <th>Cycle 5</th>
        <th>Cycle 6</th>
        <th>Cycle 7</th>
        <th>Cycle 8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th><div><input size=2 type="string" id='2.6.1.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.1.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.2.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.2.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.3.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.3.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.4.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.4.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.5.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.5.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.6.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.6.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.7.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.7.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.8.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.8.9' onchange="save_table(event)"></div></th>
    </tr>
    <tr>
      <th><div><input size=2 type="string" id='2.6.9.1' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.2' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.3' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.4' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.5' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.6' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.7' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.8' onchange="save_table(event)"></div></th>
      <th><div><input size=2 type="string" id='2.6.9.9' onchange="save_table(event)"></div></th>
    </tr>
  </tbody>
</table>
<div class="table-wrapper"><table><thead><tr><th>LUOGO</th><th>Lavanderia 24h</th><th>Processore Singolo Ciclo</th></tr></thead><tbody>
<tr><td>PROCESSANDO</td><td>CLIENTE</td><td>ISTRUZIONE</td></tr>
<tr><td>PASSAGGI del PROCESSO</td><td>Lavaggio 1.45h, Asciugatura 1.30h,Stiratura 2h</td><td>Fetch 4ns, Decode 1ns, Reg read 4ns, Execution 5ns, Memory 6ns, Writeback 3ns</td></tr>
<tr><td>NOI</td><td>Siamo gestionali, proprietari di una lavanderia.</td><td>Siamo ingegneri R&amp;D, incaricati di velocizzare un computer a 1 ciclo.</td></tr>
<tr><td>VINCOLO</td><td>C'è Il covid, solo una persona alla volta può stare in una stanza. La frequenza di clienti serviti è uno ogni 5.15h -&gt; Non posso servire più di 4.36 clienti al giorno</td><td>Solo un'istruzione può essere processata in ogni dato ciclo. La frequenza di istruzioni processate è una ogni 23ns -&gt; Non posso processare più di 43.478.261 istruzioni al secondo (~43.5 MHz)</td></tr>
<tr><td>SOLUZIONE</td><td>Dividere la lavanderia in stanze, una per lavaggio, una asciugatura, una stiratura, con delle porte, le quali si aprono una volta ogni 2 ore (tempo del passaggio più lungo)</td><td>Dividere l'hardware del processore in stage, uno per ogni passaggio, con dei registri interstadio, i quali fanno passare le informazioni ogni 6 ns (tempo del passaggio più lungo)</td></tr>
<tr><td>SVANTAGGIO</td><td>Il cliente che lava dopo aver finito deve aspettare 15 minuti prima di asciugare, chi asciuga 30 minuti prima di stirare, perchè stirare è il passaggio più lungo. Ogni cliente ora ci mette 6 ore invece che 5.15.</td><td>Ogni stage tranne il più lento (MEM) avrà qualche nanosecondo di stallo prima del clock, perchè appunto bisogna aspettare MEM. Ogni istruzione ci mette di più a essere processata, cinque volte il ritardo maggiore (30ns) invece che la somma dei ritardi (23ns).</td></tr>
<tr><td>VANTAGGIO</td><td>Viene processato un cliente ogni 2 ore (tempo del passaggio più lento)  invece che 5.15 (somma di tutti i passaggi), perchè tre clienti alla volta PARALLELAMENTE stanno dentro la lavanderia → Servo 12 clienti al giorno invece che 4.36</td><td>Viene processata una istruzione ogni 6ns (tempo del passaggio più lento) invece che 23ns (somma di tutti i passaggi) perchè cinque istruzioni sono nella pipeline PARALLELAMENTE in ogni dato momento -&gt; Processo 166.666.667 istruzioni al secondo (167MHz invece che 43.5MHz)</td></tr>
<tr><td>TRICK</td><td>Non si processano 3 clienti IN BLOCCO alla volta, poi altri 3 poi altri 3. Ma 3 clienti alla volta IN OGNI DATO MOMENTO, ne esce uno ne entra un altro.</td><td>Non si processano 5 istruzioni IN BLOCCO alla volta, poi altre 5, poi altre 5. Ci sono 5 istruzioni IN OGNI DATO MOMENTO nela pipeline, ma ne entra una ne esce un'altra, ne entra una ne esce un'altra.</td></tr>
</tbody></table>
</div><style type="text/css">
   input {font-weight:bold;}
</style>
<script>
    for (var i=1; i<10; i++) {
        for (var j=1; j<10; j++) {
            var id = '2.6.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) { localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script><div style="break-before: page; page-break-before: always;"></div><h1 id="esercizi-1"><a class="header" href="#esercizi-1">Esercizi</a></h1>
<ol>
<li>Abbiamo visto il ritardo di propagazione del circuito Incrementer essere teoricamente di quasi 90 unità di tempo. Cosa cambia essendo uno dei due addendi sempre 1? Qual è il caso di maggior ritardo effettivo di propagazione per l'Incrementer?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soluzioni-1"><a class="header" href="#soluzioni-1">Soluzioni</a></h1>
<ol>
<li><code>Abbiamo visto il ritardo di propagazione del circuito Incrementer essere teoricamente di quasi 90 unità di tempo. Cosa cambia essendo uno dei due addendi sempre 1? Qual è il caso di maggior ritardo effettivo di propagazione per l'Incrementer?</code> Se uno degli addendi è sempre lo stesso numero, non succederà mai in alcun Full Adder che tutti gli input cambino nello stesso momento (caso di maggior ritardo per il componente Full Adder). Al massimo cambieranno due alla volta (il primo addendo e il carry), diminuendo il ritardo del Full Adder di almeno 5 unità di tempo (da 12 a 7). Il caso di maggior ritardo è 127+1: infatti il carry deve attraversare tutti i Full Adder per produrre il risultato corretto (7x7+5 = 54 unità di tempo contro le precedenti 12x7+5=89).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="costruzione-pipeline"><a class="header" href="#costruzione-pipeline">Costruzione Pipeline</a></h1>
<iframe width="854" height="480" src="https://www.youtube.com/embed/fYGnEghKAKI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="indice-2"><a class="header" href="#indice-2">Indice</a></h3>
<ul>
<li><a href="./3.1_from_singlecycle.html">Dal Single-Cycle</a></li>
<li><a href="./3.2_exercises.html">Esercizi</a></li>
<li><a href="./3.3_soluzioni.html">Soluzioni</a></li>
<li><a href="./3.4_stages.html">Stages</a></li>
</ul>
<h2 id="transcript"><a class="header" href="#transcript">TRANSCRIPT</a></h2>
<p>This tutorial is an unofficial Introduction to Ripes two point two point three.</p>
<p>RIPES is a graphical processor simulator and assembly code editor for educational purposes. It was written by Morten Petersen. The program itself is theoretically architecture agnostic, but we can see in the processor selector that it currently only offers RISC-V single stage, pipelined and dual issue processors. Each processor has an extended layout for more visualization detail and settings for extensions or register initialization.</p>
<p>Onto the prorgam itself, the EDITOR TAB contains the tools to program in assembly. Programs are loaded via File&gt;Load Program. It is currently biased towards RV32I (and depending on the processor M/C) assembly. On the left hand side actual assembly can be written (or C if you link a RISC-V compiler in the settings). On the right hand side is the machine code in hex, disassembled or binary form.</p>
<p>The execution of a program can be controlled either step by step (forwards and also backwards in time), or setting a clock time and then pressing play. The execution can be reset or played without updating the ui for faster execution. If executing on a pipelined processor, on the right hand side of the editor tab it is displayed what stage the instruction is currently in.</p>
<p>The PROCESSOR TAB contains the hardware visualizations. The visualization itself is very intuitive: wires' can be highlighted for reading their path better and their value can be accessed by hovering (and can have any radix) (if they are 1 bit wide they are colored green when value is 1 and grey when value is 0, if they are multibit, they just flash yellow if updated at a given clock and remain grey if not updated). The selected option of muxes is colored green and a similar visualization is used for useful indicators, like branch taken. The other components tend to be self explanatory, by naming I/O explicitly.  CTRL+Scroll  is for zooming. On the right the register file is displayed. Values can be edited manually. Pipelined processors show the currently processed instruction above each stage. </p>
<p>The layout can be changed if needed. Just unlock it from outside the visualization square, and modify at your wish. At any point you can save the layout as json file by right clicking on the visualization square. Saved layouts can be loaded back only when layout is unlocked by right clicking on the visualization square. </p>
<p>On the bottom right is the instruction memory which for each instruction offers the possibility to insert breakpoints, other than again giving information about address and current stage. Here some statistics are given: Number of cycles, retired instructions, CPI, IPC, clock rate. Here is the console that prints ecall print functions. Finally, the table button brings up the pipeline diagram at the current cycle.</p>
<p>The visualization is easier on the eyes in view &gt; dark mode and all values can be shown or hidden under view &gt; show processor signal values.</p>
<p>Under the MEMORY tab the whole Data Memory can be accessed, either by scrolling or with the goto options below. </p>
<p>Cache and I/O tabs are used for, well, studying cache and Input/Output but the detail for those is for another video. </p>
<p>All of the processor designs can be modified in the source, for example for modifying the hazard unit of the 5 stage pipelined 32 bit processor one can modify the src/processors/RISC-V/rv5s/rv5s_hazardunit.h. The hardware description language is VSRTL, a domain specific language embedded in C++ by the same author. After modifying, Ripes has to be re-compiled. See instructions in the github repositories, links in the description.</p>
<p>If you are not familiar with the pipeline feel free to skip the rest of the video and come back if you need :)</p>
<p>Taking as reference the visualization of a pipelined single issue processor design, the student can use three overlapping but different ”perspectives of focus” when studying and playing with RIPES: 
The stage view, or vertical view, focuses on checking if a given stage is modified by different kinds of instructions according to the students expectations: for the simplest example let us consider the IF stage. We expect thes hexes out of the instruction memory, and we can verify it when the corresponding instructions pass in in the IF stage. For the ID stage, we expect for example the add instruction to enable the write back flag and the store not to. We can again verify. For the EX stage and the add instruction, we expect the first input of the alu to be the content of the register 1, and we can verify it again. This was the stage or vertical view. 
The instruction view, or cross view, focuses on following the instruction along the pipeline to understand its impact. This is the same thing as the previous focus, just under another perspective. For example the student has to notice that in whatever stage the instruction is in, it &quot;drags&quot;' with it the values it needs as they were when the instruction was in the stage in which they were created. For example the PC here is the current value, here is the previous, which was current when this instruction was in IF stage et cetera. This was the instruction or cross view.
The pipeline view, or horizontal/global view, focuses on the evolution and global impact of signals within the pipeline: this is a combination of the previous two focuses. For example in the ID stage, the Write Register flag is produced here on the control unit and used here on the Register file, but there isn't any direct connection: it has to go all the way through the EX, MEM, and WB stages and come back to the ID stage, because it has to wait for the write data, that you see also coming from the WB stage, to be retrieved in the MEM stage in case of a load, or to be calculated in the EX stage in case of many other instructions. In each following stage the value of the write register flag is the that produced by the Control unit when the corresponding instruction was in the ID stage, so the value currently being used by the register file in the ID stage, which comes looping back from the WB stage, corresponds not to the one being produced by the instruction currently in the ID stage but to the one being produced by the instruction currently in the WB stage. So the instruction currently in WB is writing back to the register file only now, even if topologically the register file is in the ID stage and even if that same instruction already passed through it three cycles ago. The write register flag was ready then, but the data to write was not. So, the write register file had to be &quot;dragged&quot; along until the stage in which the actual write back was going to happen. This was the pipeline or horizontal or global focus. </p>
<p>That is all, thank you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-single-cycle"><a class="header" href="#from-single-cycle">From Single-Cycle</a></h1>
<div class="p2p_container" id='screenshots/single_cycle_standard.png'></div>
<table class="table">
  <thead>
    <tr>
        <th>Stage</th>
        <th>Which component are in this stage?</th>
        <th>Which signals come from the following stages?</th>
        <th>Which signals go towards previous stages?</th>
        <th>Which signals go into the interstage register towards the next stage?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>IF</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>ID</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>EX</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>MEM</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>WB</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
  </tbody>
</table>
<script>
    for (var i=1; i<6; i++) {
        for (var j=1; j<5; j++) {
            var id = '3.1.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) {localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script>
<h2 id="transcript-1"><a class="header" href="#transcript-1">Transcript</a></h2>
<p>It is now the time to build the actual pipelined processor. As we anticipated during the last part of the lesson, the point is to divide the components of the processor by function and to divide the clusters with registers. Let us then start with a quick high level recap of the flow of the instruction in the processor. </p>
<p>The processor calculates the new program counter value and retrieves the corresponding instruction from instruction memory to which it is given as address input. We will call this function &quot;Instruction Fetch&quot;, 'IF'.</p>
<p>Then, it decodes the value of all its fields, which includes retrieving the values of registers from the register file. We will call this function &quot;Instruction Decode&quot;, 'ID'.</p>
<p>Then it selects the correct inputs and the correct alu function to make the calculation corresponding to the current instruction. The branch instructions will also use the Branch Comparison chip. We will call this function &quot;Execution&quot;, 'EX'.</p>
<p>If applicable, it interacts with the data memory to either read it or write it (think the load and store instructions). We will call this function &quot;Memory&quot;, 'MEM'.</p>
<p>Again if applicable, it writes the results of the Execution or of the Memory operations to the register file. We will call this function &quot;Write Back&quot;, 'WB'. </p>
<p>Now let us build each stage, that is each of the new &quot;areas&quot; of the processor constituted by the components grouped by function and divided by registers. In doing so, we can compile the table below, which keeps track of all components and connections for each stage.</p>
<p>The first area contains the components that perform the &quot;Instruction Fetch&quot; function, which means the Program counter register, the mux that selects its next value, the plus four adder and of course the instruction memory. The other chips, like the decode chip, are part of the next stages as they are, well, decoding the instruction, not just fetching it.</p>
<p>Now that we have the components, we ought to recognize which signals go into the interstage register towards the next stage, which will be all the signals that are needed in the following stages of the processors, and which signals come from one of those following stages, which are usually needed when a signal that controls one of the components in a given stage is calculated in one of the following stages. Since this is the first stage there will be no signal going towards previous stages, but those will be needed in the following stages when &quot;sending back&quot; the signals that are calculated after they are needed. This will be more clear as we go along.</p>
<p>Of the outputs of the components of this stage, all three are needed in the following chips: the instruction signal is needed in the decode chip, the program counter signal in one of the alu operator muxes, the program counter plus four signal in the mux that selects the register file write data. They therefore all go into the interstage register, which since they are all 32 bit signals will be 96 bits wide. </p>
<p>Of the inputs of the components only one is not covered bu neither the components themselves nor signals coming from the previous stage, that is the input of the mux that selects the next program counter value linked to the alu result. For example a branch instruction with its branch taken needs the alu to calculate its branch address to feed the program counter. This is an example of a signal that is calculated in a later stage and sent back to a previous one.</p>
<p>The second area contains the components that perform the &quot;instruction decode&quot; function, which means firstly extracting opcode and source register indexes, therefore we need the decode chip, secondly the value of said registers, so we need the whole register file, and finally the immediates if any, so we need the immediate chip.</p>
<p>Of the outputs of these components, all three are needed in the following chips: the two values of the source registers are needed as inputs of the alu and of the branch comparison chip, as well as data memory for the source register 2, while the immediate is only needed as alu input. Note that since the program counter signal is not used here, it has just to be passed through towards the next stage.</p>
<p>Of the inputs of the components, again only one is not covered by the components themselves, which is the register file data in, calculated al the way back at the last mux. This is calculated at the end of all other operations because many signals can be written in a register: arithmetic operations instructions write the alu result, loads write the memory output, jumps write the program counter plus four signal. There is however one observation that has to be done: when writing the register file, the data in signal and the write index signal must refer to the same instruction. This is not an issue in the single cycle processor, as the whole processor is processing a single instruction at any given time, but what we are doing is dividing the processor into stages so that each stage can contain an instruction and therefore process multiple instructions at the same time. That means that being the register file and the mux that selects the data in in two different stages, when writing the register file the instruction that will be in the same stage as the register file will be different than the one that the data in signal refers to. How to make sure that the write index signal will also refers to that same instruction and not to the one currently in the decode stage? </p>
<p>The solution is cutting the write index sigal and pass it on to the interstage register towards the next stage, and pass it through all the stages until the same stage where the data in signal is calculated, to then be 'passed back' together with it. This ensure that the two signals refer to the same instruction.</p>
<p>This also means that although we are placing the register file in this decode stage, functionally it is also part of the same stage that calculates the data in signal, which we have still to build. We can say that the register file chip is part of the decode stage when reading from it, and part of the other stage when writing to it.</p>
<p>The third area contains the components that perform the &quot;execution function&quot;, that is the alu and the two muxes that select its inputs and the branch comparison chip.</p>
<p>Of the outputs of these components the alu result and the value of source register two will go in the interstage register towards the next stage, together with the write index signal from the previous stage that is not used here. The alu result is also passed back to the fetch stage, where it is used as a possible next program counter value, as we already said.</p>
<p>Of the inputs of the components, all are covered by the components themselves or by signals passed from the previous stage, therefore no external ones are needed.</p>
<p>The fourth area contains the components that perform the 'memory function', which is just the data memory.</p>
<p>Of its outputs, the only one, the data out signal, is passed to the next stage, together with the alu result signal that other than being used here as the address input of the data memory is also used as input of the register file write data selector mux, and together with the write index signal from the decode stage that is again not used here.</p>
<p>Of its inputs, both are covered by the signals coming from the previous stage, so no external ones are needed.</p>
<p>Finally we get to the last stage, consisting of the only remaining component, the register file write data selector mux, that simply passes its output and the write index to the decode stage to perform the write operation. Let us remember that functionally the register file is also part of this stage, as its write function is controlled from here.</p>
<p>We now have a rudimentary pipelined processor. In the next part of the lesson we will briefly see how each type of instruction activates eac of its stages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esercizi-2"><a class="header" href="#esercizi-2">Esercizi</a></h1>
<ol>
<li>Quanti e quali componenti sono visualizzati nella versione Extended del processore a singolo ciclo in più rispetto alla versione Standard? Dove si collocano negli stages e quali segnali rendono visibili?</li>
</ol>
<div class="p2p_container" id='screenshots/single_cycle_extended.png'></div>
<table class="table">
  <thead>
    <tr>
        <th>Stadio</th>
        <th>Quali componenti contiene lo stadio?</th>
        <th>Quali segnali arrivano da stadi successivi?</th>
        <th>Quali segnali escono verso quali stadi precedenti?</th>
        <th>Quali segnali vanno nel registro interstadio verso il prossimo stadio?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>IF</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.1.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>ID</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.2.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>EX</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.3.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>MEM</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.4.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
    <tr>
      <th>WB</th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.1' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.2' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.3' onchange="save_table(event)"></textarea></div></th>
      <th><div><textarea cols=15 rows=5 type="text" id='3.1.5.4' onchange="save_table(event)"></textarea></div></th>
    </tr>
  </tbody>
</table>
<script>
    for (var i=1; i<6; i++) {
        for (var j=1; j<5; j++) {
            var id = '3.1.' + i + '.' + j
            document.getElementById(id).value = localStorage.getItem(id)
        }
    }
    function save_table(e) {localStorage.setItem(e.target.id, document.getElementById(e.target.id).value) }
</script>
<details>
    <summary>Se necessario, click qui per l'immagine del Single Cycle</summary>
    <div class="p2p_container" id='screenshots/single_cycle_standard.png'></div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soluzioni-2"><a class="header" href="#soluzioni-2">Soluzioni</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stadio</th><th style="text-align: left">Quali componenti contiene lo stadio?</th><th style="text-align: left">Quali segnali arrivano da stadi successivi?</th><th style="text-align: left">Quali segnali escono verso quali stadi precedenti?</th><th style="text-align: left">Quali segnali vanno nel registro interstadio verso il prossimo stadio?</th></tr></thead><tbody>
<tr><td style="text-align: left">IF</td><td style="text-align: left"><ul><li>PC</li><li>PC selector mux</li><li>PC+4 adder</li><li>Instruction memory</li></ul></td><td style="text-align: left"><ul><li>EX -&gt; ALU result</li><li>EX -&gt; PC selector</li></ul></td><td style="text-align: left">Non ci sono stadi precedenti</td><td style="text-align: left"><ul><li>Instruction -&gt; ID</li><li>PC -&gt; EX</li><li>PC+4 -&gt; WB</td></tr>
<tr><td style="text-align: left">ID</td><td style="text-align: left"><ul><li>Decode</li><li>Register File</li><li>Immediate</li><li>Control</li></ul></td><td style="text-align: left"><ul><li>(ID) WB -&gt; Write Index</li><li>(ID) WB -&gt; Write Data</li><li>WB -&gt; RF Write Enable</li></ul></td><td style="text-align: left">/</td><td style="text-align: left"><ul><li>PC -&gt; EX</li><li>Immediate -&gt; EX</li><li>Reg1 -&gt; EX</li><li>Do Branch -&gt; EX</li><li>Do Jump -&gt; EX</li><li>ALU Op1 Select -&gt; EX</li><li>ALU Op2 Select -&gt; EX</li><li>ALU Operation -&gt; EX</li><li>Branch Operation -&gt; EX</li><li>Reg2 -&gt; EX, MEM</li><li>MEM Write Enable -&gt; MEM</li><li>MEM Read Enable -&gt; MEM</li><li>MEM Operation -&gt; MEM</li><li>PC+4 -&gt; WB</li><li>RF Write Index -&gt; WB</li><li>RF Write Enable -&gt; WB</li><li>Write Data Select -&gt; WB</li></ul></td></tr>
<tr><td style="text-align: left">EX</td><td style="text-align: left"><ul><li>ALU</li><li>ALU Muxes</li><li>Branch Taken</li><li>j or (b and bt)</li></ul></td><td style="text-align: left">/</td><td style="text-align: left"><ul><li>ALU result -&gt; IF</li><li>PC selector -&gt; IF</li></ul></td><td style="text-align: left"><ul><li>Reg2 -&gt; MEM</li><li>MEM Write Enable -&gt; MEM</li><li>MEM Read Enable -&gt; MEM</li><li>MEM Operation -&gt; MEM</li><li>ALUres-&gt;MEM,WB</li><li>PC+4 -&gt; WB</li><li>RF Write Index -&gt; WB</li><li>RF Write Enable -&gt; WB</li><li>Write Data Select -&gt; WB</li></ul></td></tr>
<tr><td style="text-align: left">MEM</td><td style="text-align: left">Data Memory</td><td style="text-align: left">/</td><td style="text-align: left">/</td><td style="text-align: left"><ul><li>PC+4 -&gt; WB</li><li>ALUres-&gt;WB</li><li>Data Out -&gt; WB</li><li>RF Write Index -&gt; WB</li><li>RF Write Enable -&gt; WB</li><li>Write Data Select -&gt; WB</li></ul></td></tr>
<tr><td style="text-align: left">WB</td><td style="text-align: left">RegWr select Mux</td><td style="text-align: left">Non ci sono stadi successivi</td><td style="text-align: left"><ul><li>RF Write Index -&gt; ID</li><li>RF Write Data -&gt; ID</li><li>RF Write Enable -&gt; ID</li></ul></td><td style="text-align: left">Non ci sono stadi successivi</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="stages"><a class="header" href="#stages">Stages</a></h1>
<p>This part of the lesson explains how every stage is activated by each type of instruction. In order to do that we will use a simple list of unconnected instructions:</p>
<pre><code class="language-nasm">lui a5 30
addi sp, s0, 4
srai sp, s0, 4
sub ra, sp, gp
blt x12 x10 -12
lw a1 4(t2)
sw a1 8(t2)
jal a5 30
</code></pre>
<p>Ripes will be used for the simulation.</p>
<h2 id="transcript-2"><a class="header" href="#transcript-2">Transcript</a></h2>
<p>We will now focus on each type of instruction activates each stage. Please load the 5 stage pipelined processor with no hazard unit and no forwarding in Extended mode.</p>
<p>Load the 5 stage pipelined processor without Hazard Detection and without Forwarding in Standard mode, with no initializations and copy the program in the editor tab. Let us now start the simulation and consider the fetch stage. </p>
<p>The fetch stage contains the circuit that calculates the next Program counter value, choosing between the current value plus four (which means fetching the instruction immediately following thecurrent one, as instructions are 32 bits, or 4 bytes wide) and the alu result, that for exaple holds the destination address of branch and jump instructions. Mind however that the signal that actually makes the choice is calculated in the execution stage. Therefore we can say that although topologically this circuit belongs to the Fetch stage, it functionally belongs to the execution stage, as that is where it is controlled from.</p>
<p>As for the instruction, in this stage it has not been decoded yet, so it has no semantic meaning for the processor. This means that each instruction is treated the same way: in this stage it is just this hex number. For each instruction we can verify that its hex code is matched at the output of the instruction memory.</p>
<p>Starting from the decode stage, not all the signals in will be used by each instruction. For example the load upper immediate instruction here does not feature source registers fields, and yet we see some values nonetheless. That is because those very bits that in other instructions decode into the two source registers here are are used for something else, the immediate. Well, the processor ignores the values that have nothing to do with the current instruction, it does not use them. Therefore, we will ignore them, but you have to know the Instruction Set to know 'what' to ignore and what to check. This is particularly important because it is here in the decode stage that all the signals that control the other stages are calculated.</p>
<p>For the 'load upper immediate' instruction we can check the address of the destination register, the immediate, which is shifted by 12 positions as per instruction specification, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled since this instruction will eventually write to a register.</p>
<p>The write data select signal, which selects the alu result, which in this case will just contain a copy of the immediate.</p>
<p>Remember that the register file is being written leter, from the write back stage, through the write enable signal, the write address signal, and the write data signal. This means that the Register File chip although topologically part of the decode stage is functionally part both of de decode stage itself for its read function, but also of the write back stage for the write function. </p>
<p>The next five signals are only for memory and branch or jump instructions, so we ignore them.</p>
<p>The next three signals select the first source register and the immediate as alu inputs and 'load upper immediate' as alu function.</p>
<p>We also ignore the last signal as it is used only by branch instructions.</p>
<p>Next cycle.</p>
<p>For the 'add immediate' instruction we can check the address of the source register 1 and destination register, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled since this instruction will eventually write to a register.</p>
<p>The write data select signal, which selects the alu result, which in this case will just contain the sum of the immediate and the content of source register 1. </p>
<p>These three signals again select the first source register and the immediate as alu inputs and 'add' as alu function.</p>
<p>Next cycle.</p>
<p>For the 'shift right arithmetic' immediate instruction the analysis is mostly similar to the last instruction, except for the alu function, which is 'shift right arithmetic'.</p>
<p>Next cycle.</p>
<p>For the subtraction instruction we can check the address of the source registers and destination register. The analysis of the control unit is the same as the shift right immediate instruction except the second alu input is selected to be the content of source register 2 instead of immediate and the alu function is 'subtract'.</p>
<p>Next cycle.</p>
<p>For the 'branch less than' instruction we can check the address of the source registers, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is disabled since this instruction will not eventually write to a register, or do anything really in the memory and write back stages.</p>
<p>We ignore the write data select and the three memory signals for this very reason. </p>
<p>We ignore the do jump signal, but we check the do branch signal being enabled.</p>
<p>The next three signals select the program counter and the immediate as alu inputs and 'add' as alu function, as the alu will contain the destination address as a relative offset from the current value of program counter.</p>
<p>The last signal selects 'less than' as branch comparison.</p>
<p>Next cycle.</p>
<p>For the load instruction we can check the address of the source and destination registers, the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled since this instruction will eventually write to a register.</p>
<p>The write data select which is set to the memory output, as the value to be written to the register file will be the one retrieved from memory.</p>
<p>The next three signals instruct the memory not to write, but to read an entire word from memory.</p>
<p>We ignore the do jump and do branch flag.</p>
<p>The next three signals select the first source register and the immediate as alu inputs and 'add' as alu function, as the alu will contain the memory load address as a relative offset from the value of the source register.</p>
<p>We also ignore the last signal as it is used only by branch instructions.</p>
<p>Next cycle.</p>
<p>For the store instruction the analysis is similar to the load, except the memory is instructed to write a word, instead of reading one.</p>
<p>Next cycle.</p>
<p>Finally for the 'jump and link' instruction we can check the destination register and the immediate, and the following flags of the Control Unit from top to bottom:</p>
<p>The register file write enable which is enabled since this instruction will eventually write to a register.</p>
<p>The write data select which is set to the Program counter plus four signal, as that is the value to be saved to the register file when a jump is done. The reasons have to do with how calls in operating systems are implemented, but this is a matter for another course.</p>
<p>We ignore all the next signals except the do jump flag, which is lit, and the three flags that select the program counter and immediate as alu inputs and 'add' as alu function, as this is how the jump address is calculated, as an offset from the program counter.</p>
<p>This was all of the decode cycle. Onto the next stages, we are going to go faster as most of the functionality has already been decided.</p>
<p>The execution stage is where all actual calculations take place. This means either alu functions or branch comparisons. Note that here is also where the Program counter select signal is calculated for controlling the program counter mux in the fetch stage. Now for each instruction we will see what these operations mean. Mind that these are not the only ones, but there is at least one representative of each major category.</p>
<p>The 'load upper immediate' instruction uses the alu, which has as inputs zero and the already shifted immediate. The alu function is 'load upper immediate', which simply passes the second alu operator, the immediate, to the output. That is the value that will be written to the destination register, x15 in this case.</p>
<p>Next cycle.</p>
<p>The 'add immediate' instruction also uses the alu, with inputs the content of source register 1, which is x8 in this case, and the immediate, in this case 4. The alu function sums the two and the result is the value being written to the destination register, x2 in this case.</p>
<p>Next cycle.</p>
<p>The 'shift right arithmetic immediate' instruction uses the execution stage just like the 'add immediate' instruction, besides the alu function which is 'arithmetic shift right', which shifts right with most significant bit extension, thus maintaining the sign of the operand. </p>
<p>Next cycle.</p>
<p>The subtraction instruction uses the alu, with inputs the two source registers, x2 and x3 in this case. The alu function is 'subtract' and the result is the value being written to the destination register, x1 in this case.</p>
<p>Next cycle.</p>
<p>The 'branch less than' instruciton uses both the alu, the branch comparison chip and the program counter select circuit. The alu inputs are the prorgram counter and the immediate, which represent respectively the value of the program counter from when the branch instruction was in the fetch stage, which is 0x10 instead of the current 0x18, and the offset from it that the branch is targeting, that is -12, or three instructions back. The alu function is 'add' and the result is the branch destination address. The branch comparison chip takes as inputs the comparison type, in this case 'less than', and the values of the two source registers. Its result is a flag that signals whether the comparison is satisfied or not. The name is 'branch taken' because when the comparison is satisfied the branch is considered 'taken' and the mux selector in the fetch stage must select the destination address. Let us then study up close the program counter select circuit, which is made of one 'and' and one 'or' gate. If we notice the names of the signals, we see that the resulting flag, the program select circuit, is activated only if, case 1, the instruction is a jump instruction, or, case 2, if it is a branch instruction with at the same time the branch being taken. If you initialized no registers at the beginning of the simulation the branch should not be taken right now, as the values of both the source registers in input to the branch comparison chip are zero, thus the first one, x12, is not less than the second one, x10. Just for fun we can rewind by one cycle the simulation and create a case in which the branch is taken, for example by setting the x10 register to the value 2. Now, back at cycle 6 we can see that the program counter selector is activated and the next program counter value is going to be the current alu result, which is 4. Now go back again one cycle and reset x10 to zero so we can see the next instructions passing by the stage.</p>
<p>Next two cycles.</p>
<p>Both the load and store instructions use the alu only, with inputs the content of the first source register and an immediate. The function is 'add' and the result is the address of the data memory that they target, albeit one for reading from it and the other for writing to it.</p>
<p>Next cycle.</p>
<p>Finally the 'jump and link' instruction uses the alu much like the branch instruction, therefore calculating the sum of program counter and an offset, but bypasses the branch taken signal activating the program counter select flag, in order to jump with no conditions.</p>
<p>This was the execution stage. </p>
<p>The memory stage is only used by the load and store instructions, which are the only ones to interact with the data memory. You recognize the data memory not being used when the value of the memory operation flag is 'nop'. With the load instruction instead its value is 'load word', and with the store instruction it is 'store word'. For both we can use Memory tab to check that the value being retrieved: in the case of the load we can just check the value of the memory cell corresponding to the address in this case 2, whereas for the store we have to check that the input data, for this case zero, is written to the memory cell of the input address, in this case 8, but at the next cycle. This is due to the fact that as any register based circuit any memory shows its ouput one cycle after having received the input and the write flag.</p>
<p>Finally we come to the write back stage, which is only used by the instructions that write one of the registers, which we can recognize by the activated register file write signal. The exact register address is given by the write index signal.</p>
<p>The 'load upper immediate' instruction has the signal lit, so it writes the alu result, which in this case represents the shifted immediate. The write address is in this case 15.</p>
<p>In the next three cycles, the 'add immediate' instruction, the 'shift right arithmetic immediate' instruction and the subtraction instruction all do the same as the 'load upper immediate' instruction, with the alu result being the result of the respective operations.</p>
<p>Next cycle.</p>
<p>The branch doesn't do anything in the write back stage, and we can see the disabled register file write signal.</p>
<p>Next cycle.</p>
<p>The load instruction writes to the x11 register the output of the data memory.</p>
<p>Next cycle.</p>
<p>The store doesn't do anything in the write back stage, and we can see the disabled register file write signal.</p>
<p>Next cycle.</p>
<p>Finally the 'jump and link' instruction writes the program counter plus four signal to the register 15.</p>
<p>With this the overview of the impact of each instruction of each stage is concluded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demos"><a class="header" href="#demos">Demos</a></h1>
<p>Finally, in the next two sessions we will see the dynamic execution of two simple assembly programs on Ripes.</p>
<p>Make sure you have read <a href="./0.1_setup.html">Setup</a> and<a href="./0.2_important_info.html">Important Info</a> in order to use the Ripes virtual machine properly.</p>
<h3 id="indice-3"><a class="header" href="#indice-3">Indice</a></h3>
<ul>
<li><a href="./4.1_simple_meaningless_program.html">Simple Meaningless Program</a></li>
<li><a href="./4.2_towards_hazards.html">Towards Hazards</a></li>
<li><a href="./4.3_assignments.html">Assignments</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-meaningless-program"><a class="header" href="#simple-meaningless-program">Simple Meaningless Program</a></h1>
<ul>
<li>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></li>
<li>Registers to Initialize:
<ul>
<li><code>a0 = 0x5</code></li>
</ul>
</li>
<li>Program:</li>
</ul>
<pre><code class="language-assembly">sw a0 0xbc(x0)   # M[0xbc]=a0
li a1 0x7        # -&gt; a1 = 7
li a2 0x3        # -&gt; a2 = 3
lw a3 0xbc(x0)   # a3=M[0xbc]
LOOP:
    add a4 a0 a1     # -&gt; a4=a0+a1
    sub a5 a1 a2     # -&gt; a5=a1-a2
    add a4 a3 a3     # -&gt; a4=a3+a3
    slli a3 a3 1     # -&gt; a3=a3&lt;&lt;1
    bne a5 x0 LOOP    # Branch if a5 is different from zero
</code></pre>
<h2 id="transcript-3"><a class="header" href="#transcript-3">Transcript</a></h2>
<p>The first program actually does nothing meaningful, which helps us focus on how it flows through the processor. We will comment on each cycle of the execution. I suggest pausing the video whenever you feel like you are ready to analyse the next step yourself, and then let the video continue to verify your work. For the Fetch stage we will focus on the choice of the next PC value, for the Decode stage we will focus on the various fields and flags that influence the behaviour of the rest of the stages, for the execution stage we will focus on abstracting the alu function in relation to the instruction function, while in the last two stages we will focus on the completion of the processing of each instruction.</p>
<p>Side note, it is very important that you know hex values and ABI names by heart. For example, often values in the visualisations will be in hex while the register file on the right will have a decimal representation, or again the assembly code will use ABI register names. Make sure to know them well not to get confused.</p>
<p>First of all, load the 5 stage processor without forwarding or hazard detection with the extended layout.</p>
<p>Initialise register a0 to the value 5.</p>
<p>Copy and paste the program below in Ripes' Editor tab.</p>
<p>Let us first understand what the program does, even if meaningless. The first instruction loads the value of a0 into the memory cell with address &quot;bc&quot;. The second and the third instructions load 7 and 3 in a1 and a2 respectively. The fourth loads the content of the memory cell &quot;bc&quot; into a3. At this point we will expect a3 to hold the same value as a0.
The next three instructions are simple arithmetic operations. At the end of each we should see respectively a4 equal to 12, a5 equal to 4, a4 equal to 10, a3 equal to 10, because shifting left by 1 position is equivalent to multiplying by 2. The last instruction branches back 3 instructions (to the sub) if a5 is different from zero. Since neither a1 or a2 are being written and a5 will remain their sum, we expect the branch to continue to be taken forever, while both a3 and a4 continue to be doubled forever at each loop.</p>
<p>Cycle Zero.</p>
<p>The first instruction is in the Fetch Stage. We can see that the instruction in hexadecimal coming out of the instruction memory matches the one of the first instruction. This can be done with all following instructions. As we can see from this mux, the next program counter value will be the current one plus four, which means that the instruction immediately following the store, in this case the load immediate, or addi, will be loaded. This will not always be the case, we will see what happens when the branch reaches the ex stage, which is where this mux that chooses the next program counter is controlled from.</p>
<p>Cycle One.</p>
<p>For the Fetch stage the same considerations apply as before.
At the same time the Decode stage now contains the store instruction. I remind you that not all the signals in this stage are used by each instruction. For example the store instruction does not have a destination register field, as it uses that same bit range to encode part of the immediate, but we can see some value here nonetheless. Well, the processor ignores the values that have nothing to do with the current instruction, it does not use them. Therefore, we will ignore them, but you have to know the Instruction Set to know 'what' to ignore and what to check. For the store instruction, we can verify that r1, which is x0, and r2, which is x10, are indeed retrieved from the register file. At the beginning of the program we expect x10 to contain the value 5, and we can verify it here. Also the immediate output corresponds to the expected value of 188. We can also verify that the register file write enable is not activated, as the store instruction does not have to write to the register file when it gets to the write back stage. On the other hand, the data memory write enable is active, as the store instruction will write to data memory in the mem stage. The other lit signal is the one that on the next cycle will control the input of the second operator of the alu, selecting the immediate. Finally, one of the signals that is always a good measure to check is the alu control, which now has the value &quot;add&quot;. Why does a store instruction use the addition function of the alu? Well, it is because it calculates the address for writing the data memory by adding an offset, in this case 188, to the value of a register, in this case x0.</p>
<p>Cycle Two.</p>
<p>The execution stage now contains the store instruction and as expected the alu is summing the immediate 188 with the content of x0, which is always zero, resulting in 188. This value will be used to address the data memory during the next cycle.</p>
<p>The decode stage contains the load immediate instruction: as before we have to check only the relevant signals. In this case the register file write enable, as this instruction will write 7 in register x11 in the write back stage. The immediate 7, and the flag that allows the alu to use it, as well as the alu control flag, which is once again set on &quot;add&quot;. Finally, the write back select signal is set on alures. That is because in the write back stage the value that has to be written, in this case to x11, is the result of the sum of 0 and the immediate 7.</p>
<p>As an example of why we ought to ignore the non relevant signals, the register 2 index signal contains the value 7. This has nothing to do with the immediate, it is just a coincidence that the subset of bits that in other instructions make the register 2 index field happens to decode to 7 in the current addi instruction, which happens to use that subset of bits for encoding the immediate 7.</p>
<p>Cycle Three.</p>
<p>The store instruction is now in the Memory stage and it will be here that it will complete its execution. It will do nothing in the next stage, unlike most other instructions. Here we can see the memory write enable being used, after being calculated in the decode stage two cycles ago. From the decode stage also comes the data in, which is just the content of register 2 and we can confirm it is the value 5, while as already said the address comes from the execution stage, as it is just the alu result and we can confirm it being 188. </p>
<p>However, if we look in the memory tab for the memory cell 0xbc, we see that it does not contain the value 5 yet. This is because, as for any register and therefore any memory, it will show its output at the next cycle.</p>
<p>We can verify in the execution stage that the alu is indeed summing the immediate with the value zero. </p>
<p>We are not going to repeat anything about the fetch stage as it contains the very same type of instruction as last cycle. You can use it as exercise also for the next three cycles.</p>
<p>Cycle Four.</p>
<p>Here in the write back stage the instruction does nothing, but we can now verify in the Memory tab that it has actually written the value 5 into memory cell 0xbc.</p>
<p>The instruction in the memory stage also does nothing, as the addi instruction has nothing to do with the data memory. </p>
<p>Feel free to confirm your own guesses with the instruction in the execution stage with the aid of the simulator, which is similar to last cycle.</p>
<p>Finally, the decode stage contains the load: we can verify that it does write to the register file in a few cycles, that it uses the immediate 0xbc in the next stage and that it reads from data memory.</p>
<p>Cycle Five.</p>
<p>Here in the write back the load immediate instruction finally completes its processing, by selecting the alu result, that two cycles ago was calculated as the sum of 0 and 7, and writing it to the register file at index 0xb. 
Mind that at the same time another instruction is in the decode stage and is doing some other thing in parallel. Since it is an add instruction it is reading two registers from the register file. This instruction is the first of a streak of 4 arithmetic operations, two examples of which you have already seen, so we will focus on register values.</p>
<p>Analysing the assembly, we found that we expect this add instruction to retrieve the register a0 with value 5 and the register a1 with value 7 from the second instruction. However, on the right we can see that the register a1 is still zero, since the value is being written in this cycle and will be visible from the next. Fortunately, the implementation of the register file of this specific processor allows for reading a register at the same time of it being written, so with input 0xb, which corresponds to a1, we can still see the value 7. But what if this was not the case or worse, what if the previous instruction, the load, needed the value of a1 instead of x0? The value was not ready at the previous cycle. We will cover this case in the next exercise, so remember it.</p>
<p>So the add instruction correctly retrieves the correct values of 5 and 7 and will write their sum in register 14 in the write back stage.</p>
<p>Cycle Six.</p>
<p>The next sub instruction needs the values of registers a1 and a2 being 7 and 3 respectively. Again while a1 is ready from the previous cycle, a2 is being written to the register file right now, as you can see, but thanks to the implementation of this specific register file can still be used by the sub instruction.</p>
<p>Cycle Seven.</p>
<p>The same happens now, when the load instruction is writing 5 to the register a3 from the write back stage and the instruction in the decode stage needs to use it, even twice.</p>
<p>Cycle Eight.</p>
<p>None of the add and sub instructions do anything in the memory stage and they complete their execution in the write back stage. Now, the first instruction of the streak is here in the write back and all the others will complete here in the next cycles in the same way.</p>
<p>Cycle Nine.</p>
<p>Now the branch instruction is in the decode stage and needs the value of a5, which again is being written at the same time with the value 4. Being the last instruction of the program, the fetch stage remains empty. For confirmation we can see the program counter value in the fetch stage being 24, that is the address of the instruction just after the branch, which is empty. If you manage to sneak a malicious instruction there, congratulations, you have created a very rudimentary virus.</p>
<p>Anyway let us focus on the decoding of the branch instruction. The three lit flags are the do branch flag and the two flags that switch the alu inputs from register 1 and register 2, to program counter and immediate respectively. The alu operation is again &quot;Add&quot;, as the branch instruction in the next cycle will sum the program counter and the negative immediate to obtain the address of the instruction to jump backwards to.</p>
<p>Remember that the difference between jump and branch is that the jump requires no condition, while the branch does. </p>
<p>Cycle Ten.</p>
<p>The first two stages are empty as whether the branch is taken is going to be calculated in this cycle in the execution stage. You can see the branch taken flag being activated and ultimately selecting, back in the fetch stage, the result of the alu as next program counter. For how the inputs of the alu are set up, this new value is the program counter value from when the branch instruction was in the fetch stage, that is its address, minus 16, which is the distance in bytes of the label from it. The branch instruction will do nothing in the next two stages. At the next cycle the instruction corresponding to the new program counter value will be retrieved, which is the first instruction of the loop.</p>
<p>From now on the execution will continue in a similar way indefinitely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="towards-hazards"><a class="header" href="#towards-hazards">Towards Hazards</a></h1>
<ul>
<li>
<p>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></p>
</li>
<li>
<p>Registers to Initialize:</p>
<ul>
<li><code>t1 = 0x123</code></li>
<li><code>t2 = 0xbc</code></li>
<li><code>a0 = 0x00000fff</code></li>
</ul>
</li>
<li>
<p>Program:</p>
</li>
</ul>
<pre><code class="language-assembly">sw t1 0(t2)         # M[oxbc] = 0x123
LOOP:
   lw a1 0(t2)      # a1 = M[0xbc] 
   add a2 a1 a1     # a2 = a1+a1
   sw a2 0(t2)      # M[0xbc] = a2
   blt a2 a0 LOOP   #jumpif a2&lt;a0
</code></pre>
<h2 id="transcript-4"><a class="header" href="#transcript-4">Transcript</a></h2>
<p>Now onto the next demo.</p>
<p>Load the 5 stage processor without forwarding or hazard detection with the extended layout. This is the same processor as the last demo.</p>
<p>Initialise register t1 to the value 0x123, t2 to the value 0xbc, a0 to the value 0x00000fff.</p>
<p>Copy and paste the program below in Ripes' Editor tab.</p>
<p>Let us first understand what the program does. The first instruction loads the value of t1 into the memory cell with address &quot;bc&quot;, which unlike the last program is addressed with a register instead of with an offset. The second instruction loads such value into the register a1. The next instruction sets a2 to two times a1 and then the program stores this value in the same memory cell as before. Then the program jumps to the start of the loop if a2 is less than a0. Basically, the program doubles the value inside a2 at each loop execution until it becomes greater than a0 and it stops. By changing the initialization of a0 we can control how long the program will run (bigger a0 means it runs for more cycles).</p>
<p>Onto the program, let us focus mainly on the fetch stage.</p>
<p>Cycle zero to cycle two.</p>
<p>In the fetch stage, both the first and second instructions need registers which were initialised, x6 and x7, or t1 and t2. We can verify their values. Let us also keep in mind that the load instruction will write the value that it retrieves from memory to the register file in the write back stage, which means in cycle five.</p>
<p>Cycle three.</p>
<p>From the analysis of the assembly code, we saw that the add instruction, which is now in the fetch stage, uses the value of a1, or x11, that is supposed to be set by the load instruction as 0x123. However, we can see that the value being retrieved for the address 0x0b, which is x11, is zero. That is because, as we were saying for the previous cycle, the load instruction will write the a1 register in cycle five, that is in two cycles. By then the add instruction will be in the memory stage and cannot use the alu anymore to calculate its sum. </p>
<p>Imagine being the engineers that invented the pipeline. You just subdivided the execution of instruction into 5 stages, which execute each in less time with respect to the full activation of the processor. This lets you process more instructions in the same amount of time, mainly because the execution of each happens in parallel to that of four other instructions at any given time. However, this also means that each instruction begins its execution when two or three other instructions are still not completely executed, which is the same as to say that any register that is modified by a given instruction is not actually modified until at least three cycles later. So what if, as in this case with the register a1, the instruction that immediately follows the load needs the loaded value? More in general, given any instruction that modifies the value of a register, what if an instruction immediately after needs to use the new value of that register?
If the problem propagates, it means that execution will contain errors and it cannot be continued. </p>
<p>In cycle five we see that the result of the alu is zero and not the expected 0x246, because the values of the registers were retrieved as zero instead of the expected 0x123. This means that the value that will be written to the a2 register will be zero, which is wrong.</p>
<p>The answer to the question is therefore that no, the execution cannot be continued as the current implementation of the pipeline leads to errors.</p>
<p>How to solve problems like this will be the topic of the next lesson, and as assignment you will be asked to analyse another assembly program that contains a slightly different type of error and write a small report detailing how you found it much in the same way in which we have commented on the last two programs.</p>
<p>You will also be asked to speculate a solution, based on the following part of the lesson (and, if you want some spoilers, by trying to understand how the other three pipelined processors available in Ripes solve the problem. Mind that this is not strictly necessary as those processors will be the main topic of the next lesson) .</p>
<p>Back to our problem, hopefully you have now understood the need for some tweaks to the current pipeline hardware. Let us then try to understand intuitively how this can be solved, which again will be the topic of the next lesson. </p>
<p>In this particular case, the load instruction is writing back to the register file the value 0x123 in cycle five, while the following instruction, the add, uses it in cycle five. This kind of occurrence is called a hazard (or more precisely a dependence, which is a possible hazard). There are two ways to make sure that the add can retrieve that value. </p>
<p>The first way is to make sure that the add instruction is in the fetch stage at cycle five. This implies &quot;stalling&quot; it there for two cycles, by disabling the IDEX interstage resgister, while the load continues executing. This also implies that all instructions after the add instruction will be stalled, as if in a cue. Naturally, there would be the need of a chip that detects such occurrences, called a Hazard Detection Unit.</p>
<p>Another way is to pinpoint where exactly the value that the load instruction is going to write to its destination register is ready, or where it is really needed. In our case, the value is ready as soon as it is retrieved for memory, in the memory stage, which is one cycle before the original case. At the same time, the value is retrieved in the decode stage but it is not needed there, it is only needed for the alu in the execution stage, that is one cycle after the original case. It is possible to forward the needed value from a point of the pipeline to another inorder to minimise the stall cycles of an instruction that is waiting for a value to be ready. This means in our case to forward the value 0x123 from the write back stage directly to the execution stage, so that the add instruction must only wait for one cycles instead of two.</p>
<p>In the next lesson we will see exactly how to generalise this.</p>
<p>In the meanwhile good luck with your work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignments"><a class="header" href="#assignments">Assignments</a></h1>
<ol>
<li>Simulate the program below in a similar way to the previous lesson. Write a small report (~1 page) in which you describe what execution error you found and how you recognized it, together with what the consequence on the execution of the whole program is. Comment what the assembly does before simulating it and specify any signal that you reckon holds the wrong value and specify why it should hold the value you think is correct. Try to describe what is similar and what differs with the execution error found in the program of the previous lesson. Finally, describe how this error could be solved by using stalls or forwarding values between stages. Do not be afraid to speculate or get this last point wrong, the topic of the next lesson will be exactly this.</li>
</ol>
<ul>
<li>
<p>Ripes Processor: <code>5-stage processor (w/o forwarding or hazard detection) Extended</code></p>
</li>
<li>
<p>Registers to Initialize:</p>
<ul>
<li><code>t1 = 0x123</code></li>
<li><code>a0 = 0x00000fff</code></li>
</ul>
</li>
<li>
<p>Program:</p>
</li>
</ul>
<pre><code class="language-assembly">LOOP:
    add t1 t1 t1 # a2 = t1+t1
    bgt t1 a0 20 #jumpif t1&gt;a0
    add a1 t1 t1 # a1 = t1+t1
    sub a2 t1 t1 # a2 = t1-t1
    j LOOP
</code></pre>
<!-- 2. A COPPIE: la prima persona sceglie uno stage qualunque e un programma tra gli esempi sotto, e "gioca" nel ruolo di tale stage, mente la seconda nel ruolo dello stage successivo. Seguendo come reference la tabella della sezione [4.3](./3.3_soluzioni.md) la prima persona calcola e comunica alla seconda i dati relativi al proprio stage (ultima colonna della tabella), la seconda deve dedurre che istruzione sta nello stage precedente e calcolare di conseguenza i dati relativi al proprio stage nel prossimo ciclo. Ci si corregge con il simulatore, idealmente operato dalla prima persona. Dopo qualche istruzione ci si inverte. Questo esercizio è utile in quanto simile a uno degli esercizi d'esame.
- ESEMPIO:
    - PERSONA 1 sceglie il primo programma tra quelli sotto e lo stage MEM. I dati che passa al collega sono:
        - PC+4 -> 0xc
        - ALUres-> 0x20
        - Data Out -> 0x0
        - RF Write Index -> 0x0
        - RF Write Enable -> 0x0
        - Write Data Select -> 0x1
    - PERSONA 2 riconosce che la prima istruzione nello stage MEM è lo store e calcola i propri dati al prossimo ciclo.
        - RF Write Index -> 0x0
        - RF Write Data -> 0x20
        - RF Write Enable -> 0x0


## Esempi di programmi dall'internet

```assembly
addi x2, x0, 1

loop:
  sub x1, x1, x2
  sw  x1, 4(x0)
  blt x0, x1, loop
```

```assembly
 addi x5,x0,0x11        # set x5 to 0x11
  sw x5, 0x100(x0)       # store at address 0x100
  lw x6, 0x100(x0)       # get from mem
  addi x6,x6,1          
  sw x6, 0x104(x0)       # store to mem 0x104
```

```assembly
   addi x3,x0,0    # i = 0
   addi x4,x0,10   # const 10
loop:
   bge  x3,x4, exit
   addi x3,x3,1
   j loop
exit:
```

```assembly
  addi x3,x0,0       #  s = 0
  addi x4,x0,0       #  i = 0
  addi x5,x0,5       #  const 5
  addi x6,x0,0x100   #  base address of ax[]
  addi x8,x0,0       #  offset = 0
loop:
  bge x4, x5, exit
  add x7, x6, x8    # compute effective address
  lw  x9, 0(x7)     # get ax[i]
  add x3, x3, x9    # s = s + ax[i]
  addi x8, x8, 4    # next element
  addi x4, x4, 1    # increment index
  j loop
exit:
``` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>Embedded below is the pdf summorizing the entire RISC-V instruction set (RV32IMAC), which is useful during most lessons. The pdf is structured as follows:</p>
<ul>
<li><code>p.1</code> - Instructions on how to read the tables.</li>
<li><code>p.2</code> - Registers Table.</li>
<li><code>p.3-5</code> - Encoder Table (to translate assembly into binary machine code manually).</li>
<li><code>p.6-7 </code> - Decoder Table (to translate binary machine code into assembly manually)</li>
</ul>
<p><a href="https://nbviewer.org/github/magiwanders/pipeline_lesson/blob/main/RV32IMAC_Sliderule_Encoder_Decoder_v0.1.6.pdf" target="_blank">Open PDF in another tab</a></p>
<iframe src="https://nbviewer.org/github/magiwanders/pipeline_lesson/blob/main/RV32IMAC_Sliderule_Encoder_Decoder_v0.1.6.pdf" width="100%" height="720" allow="autoplay"></iframe><div style="break-before: page; page-break-before: always;"></div><h1 id="post-test"><a class="header" href="#post-test">Post-test</a></h1>
<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfH-oU2WTOTTIe-ch8mUYCiCtS1ZqiZnJ1oIML5n-f2ptIp8Q/viewform?embedded=true" width="100%" height="1000" frameborder="0" marginheight="0" marginwidth="0">Loading…</iframe>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="submodules/js_builds_html/html_builders.js"></script>
        <script type="text/javascript" src="submodules/paint2pic/p2p.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/digitaljs_webpack_backup.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/lz-string_backup.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/sheas_functions.js"></script>
        <script type="text/javascript" src="submodules/simple_hardware_editor_and_simulator/sheas_builders.js"></script>
        <script type="text/javascript" src="lesson.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
