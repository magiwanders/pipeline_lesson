# Stages

This part of the lesson explains how every stage is activated by each type of instruction. In order to do that we will use a simple list of unconnected instructions:

```nasm
lui a5 30
addi sp, s0, 4
srai sp, s0, 4
sub ra, sp, gp
blt x12 x10 -12
lw a1 4(t2)
sw a1 8(t2)
jal a5 30
```

Ripes will be used for the simulation.

## Transcript

We will now focus on each type of instruction activates each stage. Please load the 5 stage pipelined processor with no hazard unit and no forwarding in Extended mode.

Load the 5 stage pipelined processor without Hazard Detection and without Forwarding in Standard mode, with no initializations and copy the program in the editor tab. Let us now start the simulation and consider the fetch stage. 

The fetch stage contains the circuit that calculates the next Program counter value, choosing between the current value plus four (which means fetching the instruction immediately following thecurrent one, as instructions are 32 bits, or 4 bytes wide) and the alu result, that for exaple holds the destination address of branch and jump instructions. Mind however that the signal that actually makes the choice is calculated in the execution stage. Therefore we can say that although topologically this circuit belongs to the Fetch stage, it functionally belongs to the execution stage, as that is where it is controlled from.

As for the instruction, in this stage it has not been decoded yet, so it has no semantic meaning for the processor. This means that each instruction is treated the same way: in this stage it is just this hex number. For each instruction we can verify that its hex code is matched at the output of the instruction memory.

Starting from the decode stage, not all the signals in will be used by each instruction. For example the load upper immediate instruction here does not feature source registers fields, and yet we see some values nonetheless. That is because those very bits that in other instructions decode into the two source registers here are are used for something else, the immediate. Well, the processor ignores the values that have nothing to do with the current instruction, it does not use them. Therefore, we will ignore them, but you have to know the Instruction Set to know 'what' to ignore and what to check. This is particularly important because it is here in the decode stage that all the signals that control the other stages are calculated.

For the load upper immediate instruction we can check the address of the destination register, the immediate, and the following flags of the Control Unit from top to bottom:

The register file write enable which is enabled since this instruction will eventually write to a register.

The write data select signal, which selects the alu result, which in this case will just contain a copy of the immediate.

Remember that the register file is being written leter, from the write back stage, through the write enable signal, the write address signal, and the write data signal. This means that the Register File chip although topologically part of the decode stage is functionally part both of de decode stage itself for its read function, but also of the write back stage for the write function. 

The next five signals are only for memory and branch or jump instructions, so we ignore them.

The next three signals select the first source register and the immediate as alu inputs and 'load upper immediate' as alu function.

We also ignore the last signal as it is used only by branch instructions.

Next cycle.

For the add immediate instruction we can check the address of the source register 1 and destination register, the immediate, and the following flags of the Control Unit from top to bottom:

The register file write enable which is enabled since this instruction will eventually write to a register.

The write data select signal, which selects the alu result, which in this case will just contain the sum of the immediate and the content of source register 1. 

These three signals again select the first source register and the immediate as alu inputs and 'add' as alu function.

Next cycle.

For the 'shift right arithmetic' immediate instruction the analysis is mostly similar to the last instruction, except for the alu function, which is 'shift right arithmetic'.

Next cycle.

For the subtraction instruction we can check the address of the source registers and destination register. The analysis of the control unit is the same as the shift right immediate instruction except the second alu input is selected to be the content of source register 2 instead of immediate and the alu function is 'subtract'.

Next cycle.

For the 'branch less than' instruction we can check the address of the source registers, the immediate, and the following flags of the Control Unit from top to bottom:

The register file write enable which is disabled since this instruction will not eventually write to a register, or do anything really in the memory and write back stages.

We ignore the write data select and the three memory signals for this very reason. 

We ignore the do jump signal, but we check the do branch signal being enabled.

The next three signals select the program counter and the immediate as alu inputs and 'add' as alu function, as the alu will contain the destination address as a relative offset from the current value of program counter.

The last signal selects 'less than' as branch comparison.

Next cycle.

For the load instruction we can check the address of the source and destination registers, the immediate, and the following flags of the Control Unit from top to bottom:

The register file write enable which is enabled since this instruction will eventually write to a register.

The write data select which is set to the memory output, as the value to be written to the register file will be the one retrieved from memory.

The next three signals instruct the memory not to write, but to read an entire word from memory.

We ignore the do jump and do branch flag.

The next three signals select the first source register and the immediate as alu inputs and 'add' as alu function, as the alu will contain the memory load address as a relative offset from the value of the source register.

We also ignore the last signal as it is used only by branch instructions.

Next cycle.

For the store instruction the analysis is similar to the load, except the memory is instructed to write a word, instead of reading one.

Next cycle.

Finally for the 'jump and link' instruction we can check the destination register and the immediate, and the following flags of the Control Unit from top to bottom:

The register file write enable which is enabled since this instruction will eventually write to a register.

The write data select which is set to the Program counter plus four signal, as that is the value to be saved to the register file when a jump is done. The reasons have to do with how calls in operating systems are implemented, but this is a matter for another course.

We ignore all the next signals except the do jump flag, which is lit, and the three flags that select the program counter and immediate as alu inputs and 'add' as alu function, as this is how the jump address is calculated, as an offset from the program counter.

This was all of the decode cycle. Do not worry, the others are easier.

