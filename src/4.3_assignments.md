# Assignments

1. Simulare la variante dell'ultimo esercizio visto a lezione (vedi sotto). Anche questa variante evidenzia dei limiti della pipeline: quali sono però le differenze con l'esercizio originale?
- REGISTRI DA INIZIALIZZARE```
    - ```t1 = 0x123```
    - ```t2 = 0xbc```
    - ```a0 = 0x000000fff```
- ASSEMBLY
```assembly
sw t1 0(t2) # M[oxbc] = 0x123
LOOP:
lw a1 0(t2) # a1 = M[0xbc]
add a2 a1 a1 # a2 = a1+a1
bgt a2 a0 16 #jumpif a2>a0
sw a2 0(t2) # M[0xbc] = a2
j LOOP
END:
```

2. A COPPIE: la prima persona sceglie uno stage qualunque e un programma tra gli esempi sotto, e "gioca" nel ruolo di tale stage, mente la seconda nel ruolo dello stage successivo. Seguendo come reference la tabella della sezione [4.3](./3.3_soluzioni.md) la prima persona calcola e comunica alla seconda i dati relativi al proprio stage (ultima colonna della tabella), la seconda deve dedurre che istruzione sta nello stage precedente e calcolare di conseguenza i dati relativi al proprio stage nel prossimo ciclo. Ci si corregge con il simulatore, idealmente operato dalla prima persona. Dopo qualche istruzione ci si inverte. Questo esercizio è utile in quanto simile a uno degli esercizi d'esame.
- ESEMPIO:
    - PERSONA 1 sceglie il primo programma tra quelli sotto e lo stage MEM. I dati che passa al collega sono:
        - PC+4 -> 0xc
        - ALUres-> 0x20
        - Data Out -> 0x0
        - RF Write Index -> 0x0
        - RF Write Enable -> 0x0
        - Write Data Select -> 0x1
    - PERSONA 2 riconosce che la prima istruzione nello stage MEM è lo store e calcola i propri dati al prossimo ciclo.
        - RF Write Index -> 0x0
        - RF Write Data -> 0x20
        - RF Write Enable -> 0x0


## Esempi di programmi dall'internet

```assembly
addi x2, x0, 1

loop:
  sub x1, x1, x2
  sw  x1, 4(x0)
  blt x0, x1, loop
```

```assembly
 addi x5,x0,0x11        # set x5 to 0x11
  sw x5, 0x100(x0)       # store at address 0x100
  lw x6, 0x100(x0)       # get from mem
  addi x6,x6,1          
  sw x6, 0x104(x0)       # store to mem 0x104
```

```assembly
   addi x3,x0,0    # i = 0
   addi x4,x0,10   # const 10
loop:
   bge  x3,x4, exit
   addi x3,x3,1
   j loop
exit:
```

```assembly
  addi x3,x0,0       #  s = 0
  addi x4,x0,0       #  i = 0
  addi x5,x0,5       #  const 5
  addi x6,x0,0x100   #  base address of ax[]
  addi x8,x0,0       #  offset = 0
loop:
  bge x4, x5, exit
  add x7, x6, x8    # compute effective address
  lw  x9, 0(x7)     # get ax[i]
  add x3, x3, x9    # s = s + ax[i]
  addi x8, x8, 4    # next element
  addi x4, x4, 1    # increment index
  j loop
exit:
```
